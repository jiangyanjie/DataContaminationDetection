
/*
    CPosPtr.java, generated by gen_pointer_wrapper.py.

    Copyright (C) 2010 Darrell Karbott

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2.0 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

    Author: djk@isFiaD04zgAgnrEC5XJt1i4IE7AkNPqhBG5bONi6Yks

    This file was developed as component of
    "fniki" (a wiki implementation running over Freenet).

    DON'T MODIFY THIS FILE BY HAND.
*/

package wormarc.hgdeltacoder.cptr;
import wormarc.hgdeltacoder.ported.*;

// Generated by gen_pointer_wrapper.py
public class CPosPtr {
    public CPosPtr(Pos[] rep, int pos) {
        mRep = rep;
        mPos = pos;
    }

    public CPosPtr(Pos[] rep) {
        mRep = rep;
        mPos = 0;
    }

    public final CPosPtr copyPtr() {
        return new CPosPtr(mRep, mPos);
    }

    public final CPosPtr copyPtrWithOffset(int offset) {
        return new CPosPtr(mRep, mPos + offset);
    }

    public boolean equals(Object obj) {
        if (obj == null || (!(obj instanceof CPosPtr))) {
            return false;
        }

        CPosPtr other = (CPosPtr)obj;
        if (mRep != other.mRep) {
            throw new IllegalArgumentException("Illegal comparison, pointers " +
                                               "reference different memory " +
                                               "blocks!");
        }

        return (mPos  == other.mPos);

    }

    public final int minus(CPosPtr other) {
        if (mRep != other.mRep) {
            throw new IllegalArgumentException("Illegal comparison, pointers " +
                                               "reference different memory " +
                                               "blocks!");
        }
        return mPos - other.mPos;
    }

    public final Pos deref() {
        return mRep[mPos];
    }

    public final void plusPlus() {
        mPos ++;
    }

    public final Pos bracket(int index) {
        return mRep[index + mPos];
    }

    public final Pos setValueAt(int offset, Pos value) {
        mRep[offset + mPos] = value;
        return mRep[offset + mPos];
    }

    public final static CPosPtr alloc(int size) {
        Pos[] values = new Pos[size];
        for (int index = 0; index < values.length; index++) {
           values[index] = new Pos();
        }
        return new CPosPtr(values);
    }

    public final void realloc(int size) {
        Pos[] values = new Pos[size];
        for (int index = 0; index < values.length; index++) {
           values[index] = new Pos();
        }
        mRep = values;
        mPos = 0;
    }

    public final void free() {
        mRep = null;
        mPos = -1;
    }

    public final void set(Pos[] rep, int pos) {
        mRep = rep;
        mPos = pos;
    }

    public final int pos() {
        return mPos;
    }

    public final Pos[] unsafeRep() {
        return mRep;
    }

    public String toString() {
        int allocated = 0;
        if (mRep != null) {
           allocated = mRep.length;
        }
        return "{allocated=" + allocated + ", pos=" + mPos +"}";
    }

    private int mPos;
    private Pos[] mRep;
}
