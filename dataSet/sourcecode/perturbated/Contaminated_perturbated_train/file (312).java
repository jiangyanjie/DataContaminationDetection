/*
  * Thi s sourc     e file was generated by FireStorm/DA  O.
   *   
 * If you   purchase a fu   ll license for      FireStorm/DAO you can   customize th    is h  eader file.
 * 
       * For more   i nformation p   lease visit http://www.codefutures.com/products/firestorm
 *    /

package com.mybillr.db.jdbc;

import com.mybillr.db.dao.*;
im  port com.mybillr.db.factory.*;
import com.mybillr.db.dto.*;
import com.mybillr.db.excepti     ons.*;
i  mport java.sql.Connection;
import java.util.Collection;
import org.apache.log4j.Logger;
impor  t java.sql.PreparedStatement;  
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.S    QLException;
   import java.sql.  Time;
import java.util.List;
import java.util.It     erator;
import     java.util.Array  List;

pub    lic   class AccountActivationDa oI  mpl extends AbstractD      AO               implements AccountActivation      Dao
{
	/** 
	 * The factory class for this DAO has t   wo versio       ns of the create() m  ethod - one      that
tak  es no ar    guments and one that takes     a Conn       ection argument. If the Connection    version
is  chosen then the c    onnection w   ill be stored i  n this attribute and wil    l be     used by all
calls to this DAO, otherwise a new        Connection will be alloca      ted for each operation.
	 */
	   protected jav  a.s     ql.Connection userConn;

	protected static final Logger logger = Logger.getLogger( AccountActivationDaoImpl.class );

	/** 
	 * All finder metho                ds in th  is cla   s      s use this SELECT co      nstant to bu    ild    their qu      erie    s
	 */
	protected final String   SQL_SELECT = "SELECT id, user_id, activation_hash    F    RO    M " +   getTa   bleName() + "";

	/** 
	 * Finder       methods w ill pass thi s v    alue to the JDBC set  MaxRows method
	 */
	pr            otected int maxRo    ws;   
      
	/** 
	 * SQL INSERT stat     ement for this table
	     */
	protected final String       SQL_I   NSE  RT = "  INSERT IN      TO "  + getT   ableN    ame() + " ( id,   user_id, activ     ation_hash  )   VALUES ( ?, ?, ? )";

	/** 
	 * SQL UPDATE s  tatement for this table
	       */
	protected final String SQL_UPDATE    =  "UPDATE " +  get  Ta   bleNam e() + "   SET id = ?,   user_id = ?, activation_ hash = ? WHERE id = ? AN   D   user_id = ?";

	/** 
    	 * SQL DELETE statem ent for this table
	 */    
	prote   cted final String SQL_DELETE = "DELETE FROM " + getTab    leName() + " WHE RE id = ? A    ND u       se  r_id = ?";

	/** 
	      * Index of col   umn id
	 */
	protected static final int COLUMN_ID =   1;

	/** 
	 *     Index   of column user_i d
	 */
	prote  cted static fina  l int    COLUMN_USE  R_ID =    2;

	/** 
	     * Index of c         ol    umn act    iva   ti     on_hash
	 */
	p  rotected     stat     ic final int COLUMN_ACTIVATION_HASH     = 3;
    
	/** 
	 * N     um      ber of     columns
	 */
	protected stat   ic fi    nal int NUMBE R_OF_COLUMNS = 3;

	/** 
	 * Index of primary-key column id
	 */
	protected   static final      int PK_COLUMN_ ID = 1;

	/** 
	 * Ind    ex of        primary-key c      olumn user_id
	 */
	protected static       final int PK_COLUMN_USER_ID = 2;  

	/** 
	 * Inserts a new row in the a  ccount_activation    table.
	 */
	public   AccountActivationPk inse   rt(AccountActivation dt   o) throws AccountActivationDaoException
	{
		long t1 =   System.   currentTimeMillis();
		// declare variables
		fi    nal   boolean isConnSupplied = (userConn !=   null);
        		Conn  ection conn    = null;
		Pr   epared     Statement stmt = n           ull;  
		ResultS   et rs = null;
		
		try {
			// get the user-specified connection or    get a connection fro  m the ResourceManager
		    	conn = isConnSu    pplied ? userConn : ResourceManager.getConnect     ion();
		   
			S   tringBuffer  sql = new StringBuffer();
	  		StringBuffer values =    new StringBuffer();
			sql.append( "INSERT INTO " + getTableName() + " (" );
			int m  odifiedCount = 0;
			if (dto.isIdModified()) {
				if (modifiedCount>0) {
					    sql.append( ", " );
					values.append( ", " );
				}
		
				sql.append( "id" );
			 	values.append( "?" );
				modifiedCount++;
			}
		
			if (dto.isUser   IdModifi   ed()) {
				if (modifiedCount>0) {
					sql.append( ", " )    ;
					values     .append(   ", " );
				}
		
	   			sql.append( "user _id" );
				values  .append( "?" );
				modifiedC    ount++;
			}
   		
			if (dto.isActivationHashModified(      )) {
				if (modifiedCou   nt>0) {
					sql.append( ", " );
					values.append( ", " );
				}
		
		      		sql.append( "activation_   hash  " );
				values.append( "? " );
				      modifi    e   dCount++;
			}
		
			if (modifiedCoun       t==0) {
 				// nothing to in    sert
 				throw  ne    w IllegalStateException( "Nothing to insert" );   
			}
		
			sql.append( ")     VALUES (" );
			sql.append( values );
			sql.append( ")" );  
			st   m   t = c   o  nn.prepareS   tatement( sq   l.toString(), Statement.RETURN_GENE       RA   TED_KEYS    );
			int index = 1;
			if (dto.isIdModif    ied()) {
				stmt.setInt( index++, dto.get Id() );
			}
		
			if (dto.isUserIdModified()) {
				stmt.setInt( index++, dto.getUserId() );   
			}
		
 			if (dto.is    ActivationHashModified()) {
				   stmt.setString( index++, dto.getActivationHa   sh() );
			}
		
		  	if (logger.is         D     ebugEnabled()) {
				logger.debug( "Executing " + sql.toS   tring    () + " with values  : " + dto);
			}
		
			int rows = stmt.e xecuteUpdate     (  );
			long t2 = System.currentTime   Millis    ();
 			if    (logger.i       s  DebugEnable           d   ()) {
				lo  gger  .debug( r ows + " rows affected (" + (t2-t1) + " ms) ");
			}
		
		
			    // retrieve values from auto-increment columns
    			rs = stmt.getGenera   tedK     eys();
			if (rs != null && rs.     next()) {
				dto.se    tId( rs.g    etInt( 1 ) );  
			}
		
	    		reset(dto);
			return dto.createPk();
		}
		     catch         (Excepti    on _e) {
			logg  er.error( "Exception: " + _e.getMessage(), _e );
			throw new Accou  ntActivatio   nDaoExc  eption( "Exception:    " +     _e.getMessage(), _e );
	   	}
		finall   y {
			ResourceManager.close(stmt);
			if (!isCon  nSupplied)    {
				ResourceManager.close(conn);
			}
		
  		}
		
	}

	/** 
	 * Updates a single ro w in th  e account_activation table. 
	    */
	public void update(AccountActivationPk pk, AccountAc tivation dto) throws AccountActivationDaoException
	{
		long t1 = System.currentTimeMillis()     ;
	     	/   / declare variables
		final boolean isConnSupplied =     (userConn != null);
		Connection  conn = nul      l;
		Prepared     Statement stmt = null;
		
 		try {
			// get       the           user-specified connection or get a connection from the ResourceManager
			conn = isC    onnSupplied ? userConn : ResourceManager.getConnec     tion();
		
 			StringBuffer sql = new StringBuff    er();
			sql.ap     pend( "UPDATE " + getTableName () + " SET    " );
			boolean modified   = false;
			if (dto.i  sIdModified()) {
				if (modified) {
					sql.append( ", " );
				}
		
				sql.append( "id=    ?" );
				modified=true;   
			}     
		
			if (dto.isUs      erIdModified()) {
				if (modified) {
					sq  l.append( ", " );
				}
		
				sql.append( "use  r_id=?" );
			  	modi    fie    d=true;
			}
	    	
			if (dto.i   sActivationHashModified     ()) {
				if    (modified) {
					sql.append( ", " );
				    }
		
				sq   l.a   ppend(      "activation_hash=?" );
				modified=true;
			}
		
			if (!modified) {
				// nothing to update
				return;
			}
		
			sql.append( " WHERE id=? AND user_id=?" );
			if (logg  er.isDebugEnabled(  )) {
	   			logger.debug( "Executing    " +       sql.toString() + " with values: "   + dto);
			}
		
			stmt = conn.prepareStatement( sql.toString() );
			int index     = 1; 
			i              f (dto.isIdModified()) {
				stmt.setInt( index++, dto.getId() );
			}
		
			if (dto.isUserIdModified())   {
				stmt.setInt( index      ++, dto.ge  tUserI  d   () );
			}
		
	   		if (dto.isActivationHashModified()) {
		 		stmt.setString( index++, dto.getActivationHash() );
			}
		
			stmt.setInt       ( index++, pk.getId() );
			stmt.setInt( index++, pk.getUser  Id()    );
	    	   	int rows = stmt.e      xecuteUpdat   e();
			reset(dto);
			long t2 = System.current TimeMillis();
			if (logger.isDebugEnabled()) {
			  	logger.debug( rows + " rows affected (" + (t2-t1)      + " ms)");
		  	}
		
		}
		catch (Exception _e) {
			logger.e  rror     ( "Exception: " + _e. getMessage(), _e )    ;
	    	 	  th    r  ow new AccountActi  vationDaoException( "Exception     : " + _e.getMessage(), _e );    
	   	}
		      finally {
     			ResourceManager.close(stm  t);
			if (!isConnSupplie    d) {
		  		ResourceMana g      er.     close(conn)   ;
			}
		
		}
		
	}

	/** 
	 * Deletes a single row in the account_activation table.
	 *        /
	pu blic void delete(Ac  countActivationPk pk) throws AccountActivationDaoExc  eption
	{
		l ong t1 = System.current  Tim     eMil   lis (  );
		//      declare variables
		final b   oolean isConnSupplied = (use rCon    n != null);
		Connection conn = null;  
		PreparedStatement stmt   = null;
		
		try {  
			// g   et    the user-specified   connection or ge    t a connectio     n from the Resour   ceManager
			conn = isConnSupplied ? userConn : Res      ourceManager.getCon nection();
		      
			i f (logge   r.isDebugEnabled()      ) {
				logger.debug(  "Exec   uting " + SQL_DELE  TE + " with PK: " + pk);   
			}   
		
			stmt = conn.prepareStatement( SQL_DELETE );
			stmt.setInt( 1, pk.getId() );
			stmt.setInt( 2, pk.getUs    erId() );
			i    nt rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();  
			if     (logger.isDebugE  nab  led   ()) {
				logger.d     ebug( row   s + " rows affected ("       + (         t2    -t1) + " ms)"    );
			}
		
		}
		cat ch (Exception _e) {
			logger.error( "Except    ion:    " + _e.get            Me ssage(), _e );
     			thr ow new AccountActivationDaoE    xception( "Exception: " + _e.ge          tMe   ssage(), _e   );
		}
		finally {
			ResourceManager.close(stmt);
			if (!i sConn       Supplied)      {
				Re      sourceMa   nager.clos   e(conn);
			}
		
		}
		
	}

	/**    
	 *     Return       s the ro    ws from   t he a    ccount_ac tivation tab   le          that m   atch    es the specified prim ary-key va lue.
	 */
	public AccountAct  ivation find    By   P   rimaryKey(AccountActivationPk pk    ) throws Acc   o     untActivationDaoExcept   ion
	{
		return findB      yPrimaryKey( pk.getId(), pk.getUserId() );
	}

	/** 
	 * Returns all r    ows fro      m th   e account_a  ctivat  ion table that match the criteria 'id = :   id AND user_   id = : userId'.     
	 *  /
	public AccountActivation findByPrimaryKey(int id,   int userId) throws AccountActivatio  nDaoException
	{
		AccountActivation ret[] = findByD   ynamicSelect( SQL_SELECT + " WHERE id     = ? AND user_id   = ?", new Object[] {  new    Intege  r(id),  ne  w Integer(userId) }   );
		return ret.len   gth==0 ?   null  : ret[0];
	}

	/** 
	 * Returns   all rows from the     account_activation table    that match the cri       teria ''  .
	 */
	publi  c AccountActivation[] findA  ll(    ) throws AccountActivationDaoException
	{
		return fi ndByDynam   icSelect( S   QL_SELECT     + " ORDER        BY id,  user_id", null );
	   }

	/** 
	 * Retur ns al  l rows from the account_activation table that m   atch  the criteria 'user_id = :userId'.
	 */
	  public AccountActivation[] findByUse   r(int user     Id) throws AccountActivationDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE user_i        d = ?", new Object[] {  new Integer(userId) } );
	}

	/ ** 
	 * Returns all rows from the  account_activati     on table th  at matc    h the cri    teria 'id = :id'.
	 */
	pub   lic AccountActivation[] findWhereIdEquals(int id) th row  s AccountAc   tivationDao Exception
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE id        = ? ORDER BY id", new Object[]      {  new In  t     eger(id)        } );
	}
         
   	/*    * 
	 *  Returns all rows from     the account_activation table that match the criteria 'user_id = :userId'.
	 */
	public AccountActivation[] findWhereUserIdEquals(int userId) thro  ws AccountActivationDaoException
   	{
		return findByDynamicSelect( SQL_SEL    ECT + " WHERE user_id = ? ORDER BY user_id", new Object[] {  new  Integer(userId) } )    ;
   	}

	/*   * 
	 * Returns  all rows f  rom the account_activation ta  ble t      hat match the criteria 'activation_hash = :a     ctivationHash'.
	 */
	public AccountActiva    tion           [] findWhereActivationHashE  quals(Strin      g acti  vationHas    h) throws AccountActivationDaoExce   ption
	{
		return findByDynamicSelect( SQ L_SELEC    T + " WHERE activ      ation_hash = ?   ORDER BY activation_hash", new Object[] { activationHash } );
	}

	/**
	 * Method     'AccountActivationDaoI   mpl'
	 * 
	 */
	public Accou    ntActivationDaoImpl(     )
	{         
	}

	/**
	     * Method 'AccountActivationDaoImpl'
     	 * 
	 * @param userConn
	      */
	public AccountA     ctivationDaoImpl  (final  j    av    a.sql.Conne      ction userConn)
	{
		this.us    erConn = userConn;
	}

	/** 
	 * Sets    the value of maxRows
	 */
	public void setMaxRows(int maxRows)
	 {
		th  is.m    axRows = m       axRows;
	}

     	/** 
	 * Ge     ts the   value of maxRows
	 */
	public int getMaxRows ()
	{
		return maxRows;
	}

	/**
	 * Metho  d 'getTableName'
	 * 
	 *     @return String
	     */
	pub       lic String getTable     Name()
	{
		return "mybillr.account_activation";
	}  

	/** 
	 * Fetches    a single row from the    result set
	   */
	p rot  ected Accou    ntActi  va tion fetchSingleResult(ResultSet rs) thr   ow      s SQLException
	{
		if (rs.next()) {  
			AccountActivation dto = ne    w Ac  countActivation()     ;
			populateDto( dto, rs);
			return dto;
		}  else {
			retu  rn n   ull;
		}
		
	} 

	/** 
	 * Fetche    s multiple rows from the result set
	  */
	protected AccountActivati   on[] fetchMu   ltiResults(ResultSet rs) throws SQLException
	{
		Collection     r   es   ultList = new Arr  ayList(); 
		while (rs.next()) {
			AccountActiva      tion dto = new Acco    untActivation();
			popul     at            e  Dto( dto, rs);
		  	resultLis    t.add( dto );
		     }
	 	
		Acco      u  ntActivation ret[] = new AccountActivation[ resultList.size() ] ;
		resu ltList.toArray( ret );
		return ret;
	}

	/** 
	 * Populates a     DTO with da      ta from a ResultSet
	 */
	protected void     populateDto(AccountActivation dto, ResultSet rs) throws SQLExcep   tion
	{
		dto.setId( rs.    ge     tInt( COLUMN_   ID ) );
		dto.setUserId( rs.getInt( COLUMN_USER_ID ) );
		  dto.setActivationHash( rs.getString( COLU   MN_ACTIVATION_HASH ) );
		reset(dto);
	}

	/** 
	 * Resets th   e mo     dified a    ttributes in the DTO
	 */
	pr  otected void reset(AccountActivation dto)
	{
		dto.setIdModified    ( false       );
		dto.setUserIdModified  ( false );
		d    to.setActivationHashModified( false );
	}

	/*    * 
	 * Ret    urns  all rows from the account_activatio   n table th  at match the specified arbitrary SQL statement
	             */   
	public AccountActiv   ation[] fin      dByDynamicSelect(String sql    , Object[] sqlParams) throws AccountActivationDaoException
	{
		// declare variables
  		final   boolean isCo     nnSuppl  ied = (userConn != null);
		Connection conn = null;
		PreparedStatemen    t stmt =     null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or   get a connection from t     h   e Resourc eManage  r
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// const     ruct the    SQL statement
			final String SQL = s     ql;
		
		
			if (logger.isDe  bugEnabled()) {
				logger.debug ( "Executing " + SQL);
			}     
		
			// prepare stateme   nt
			stmt = conn.prepareStat  ement( SQL );
			stmt.setMaxRows( maxRows );
		
			// bind     parameters
			for (int i=0;      sq    lParams!=null && i<sqlP   arams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			} 
		
		
			rs = stmt.    executeQuery();
		
			// fetch t    he results
			return f   etchMultiResults(rs);
		}
		catch (Exception _e) {
		   	logger.error( "Ex    cep    tion: " + _e.getMessage(), _e );
			throw new AccountActivationDaoException( "Exception: " + _e.getMessage() ,       _e );
		}
		finally {
			ResourceManager     .close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied ) {
				ResourceMan     ager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Return  s all rows from the account_activation table that ma   tch the specified arbitrary SQL statement
	 */
	public AccountActivation[] findByDynamicWhe  re(String s  ql, Object[] sqlParams     ) throws AccountActivationDao    Exception
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-sp   ecifi ed connection or get a co         n   nection   from the ResourceManager
			conn = isConnSup   plied ? userConn : ResourceManager.g  etConnection();
		
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
		
		
			if (logger.i    sDebugEnabled()) {
				logger.debug( "Executing " + SQL);
			}
		
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows(   maxRows );
		
			// bind parameters
			for (int i=0; sqlParams!=null && i<sqlParams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			}
		
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return fetchMultiResults(rs);
	 	}
		catc h (Exception _e) {
			logger.error( "Exception: " + _e.getMessage(), _e );
			throw new AccountActivationDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

}
