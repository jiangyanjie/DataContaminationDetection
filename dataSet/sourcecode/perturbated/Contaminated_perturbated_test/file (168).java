/*    Generated By:Java  C  C: Do not   edit t    his li  ne. CycLParser.java    */
package org.opencyc.parser;

import org.opencyc.api.*;
import org.opencyc.cycobject.    *;   

/**
 * <P>This clas   s  implements a parser   for the C  ycL grammar. This file
 * was automatica   lly gen      erated with javacc based on the    file:     "cycl.jj".
 * Th  e      CycL parser file    s can be regenerated by calling:
 * "ja         vacc cycl.jj"
 * 
  * <P>Cha     nges from our current SubL-based CycL parser and/or 
 * current docume   ntation:
 * <UL>
 *        <LI>1. #$ExpandSubLFn       and #$           S ubLQuo teFn  are not suppor          ted
  *                        -     @Note: these seem like      a   really, 
 *           really bad thing to support i                       n th     e t      he syntax. Thi    s means that 
    *                in order to d        o the most ba    sic syntatic   checking/tok     eniz  ation o    f 
 *          Cyc    L sta   tements,    one must have     the complete knowle  dge
 *                   of the SubL     grammar...the    se wo uld probably
 *                      better be handled w   ith o    paque st   ruct  ur  es like strings           or 
 *                      sentinel del  imited sections.
 *
 *<LI    > 2. Added su                     pport for C++   style          comments.
 *            An    ything    starting from a   "//" that   isn'  t embedd     e d in  a string    
 *           on        a l ine in       a Cy    c L expression      to the     end of th   e sam    e     l   ine        
     *                     is    ignored as a comment . The lisp version    o f this with a 
 *            s    emicolon i s  al so support    ed.
             *        Embedded comments with slash-star and s    t ar-slash are al   lowed.   
 *         Nesting    of embedde  d com     men ts is not allowed.
 *
 *   <LI> 3. Don     '                t us   e SubLString and SubL Nu  mber.
 *                         I     nstead    use   expl   icit def in  itions of st  rin      gs and numb       e   rs.    
      *           Th  e     se explicit defi    nitions may                 not           exactly      correspond                to 
 *                        to t    heir SubL counterpart.
 *        For decimal      integers          we support     notatation lik   e:    1,   +1  ,    2   3, -344.
 *               For flo   ating p oint   numbe   rs: 0.1, .32, -  23.0, +2        3     4.323, 9E-  234,       
 *               +9e234, 9e+234      , -9.                    1134e-11 (als    o variations where "e" is     
   *                 replaced by "d" ar   e supported, but not    encour    aged -- 
 *                               t             he d no     tatio  n is a artifact     of    the Lisp in   te rpret  er, 
 *            w         hile t  he e nota  tion     is          a widel y adopted standard for 
  *                       scientific    n   ot  ation) .
 *              Note: flo at ing p   oint numbers t    hat co    nt    ain e,       E,d,D,- a  nd nu m              bers on    ly     
 *                   could be amibiguous     with    a non-prefi  xed cons  tant names, 
 *                 the float ing poin   t interpretation  is always ta  ken.
 *        European style      numb    ers w ith a comma as the dec       imal     separa       tor 
        *                                    are not allowe    d.
 *                   Comma separators i     n the thousands places are not            all  owed.
 *        For string    s, we su  pport asci          i characters inside of double  qu        otation
 *                marks wi   th a backslash escapes        like: "hi", "\"bye\"\    n"
 * 
 *<LI       > 4. A  dded sp  ecial sup po  rt  for parsing f rom GU          IDs  .
 *        An     y s tr in     g    preced    ed by       "#G"   is parsed       as   cons        tant w  ith    t   h  e given 
 *          GUID.
 *        Any character sequences not encl       osed in double quotes an  d
      *        containing only   hexidecimal   characters and     da   shes preceded by a "#G"
   *        ar e int  e    rpreted as a GUIDs. #g work s     t   oo.
 *
 *<  LI> 5.       No depre           cated feature         s of the language are supporte d like characters,
          *        list     terminals, SubL symbols, SubL expr  es sions etc    ..
 *
 *<LI> 6. No su  pport for HL construc ts.
 *    <UL>
     * <P>The contents of th     is file       is based on the    BNF comment
 * at the top of cy                  cl-grammar.lisp and on th    e contents and documentation
   * of     the CycL  voc      abulary in the KB, and on the current b   ehavio r of t    he system
 * wi  th a bit of cle   aning up.
 *
 * @version $Id:    CycLPars      er.   java             138070 2012 -01-10 19:46:08Z sbrown $
             * @author Tony Brusseau
        *
 *   <p>Copyright 2001 Cyco     rp,      Inc., license is open so        urce GNU LGPL.
 * <p><  a href="     h        ttp://www.       open        cyc.o   rg/licens    e        .txt">the         license</a>
 * <p><a href="h  ttp://www.open cyc.org">www.   opencyc.org</a    >
 * <p><a h         ref="http://www.sourcef          o  rge.net/projects/opencyc   ">OpenCyc   at Sour  ceF   orge<    /a>
 * <p>
 * THI S SOFTWARE AND     K    NOWLEDGE BASE CON   TENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSE      D OR IMPLIED WARRANTIES,   INCL  UDING,       BU    T NOT LIMITED TO,
 * THE IMPL  IED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * P     ART    ICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL TH       E OPENCY    C
 * ORG  ANIZATION OR   I TS CONTRIBUTORS BE L IABLE FOR ANY D    IRECT,
 *   INDIRECT, INCID    ENTA         L, SPECIAL   , EXEMPLARY, OR CO   NS  EQUE  N TIAL D   AMAGES
 * (INCLUDING,  BUT NOT LIMITED T    O,    PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVI          CES; L OSS OF USE, DATA, OR  P    ROFITS;    OR BUSINE   SS IN      TE          RRUPTION)
 * HOWEVER        C  AUSE D A   ND ON ANY THE ORY O    F LIABILITY, WHETHER I  N CONTRAC  T,
 * STRICT LIABILITY, OR TO R     T   (INCLUDING       NEGLIGENCE OR OTHERWI     SE     )
 * A   RISING IN     ANY WAY OUT OF    T    HE USE       OF TH     IS SOFTWARE  AND KNOWLE  D     GE
 * B    AS     E CONT ENT, EVEN IF ADVISED OF    THE POSSIBILIT   Y O   F  SUCH DAMAG   E.
 */
  class      CycLP arser extends Object implements CycLPars  e     r Const   ants {

     private Cyc A   ccess acce    ss;

    pub    lic  CycLP  arser   (jav      a.io.Reader       str      eam, CycAc   cess   access)     {
         this(stream   )      ;
      this.access     = access     ;
    }

    pub   lic CycAccess    getC      yc  Acc    es          s()               { return   acce       ss; }

    /**
     * The parser        program.
           *   
           * @pa       ra          m args   c   u rrently i gno        red.
        */
    public    static void main(S   t        ring[] args) {
      CycLParser parser = new CycLParser(S   ystem.in);
                 try {
        parser.ter   m(true);
      } catch   (Excep    tion     e) {
                       Sy   stem    .er    r.println(e);
      }   
    }
  
/****   ******   ****   ******* Parser  ***********   **** *****/
  f    i  nal   public CycList termList(boolean requireE         OF)          th rows ParseEx  ception , jav  a.io.IOException, UnsupportedVocabularyExc             e            ption {
  Cyc List val = n     ew CycList(   );
  Object curTe  rm = null;
        label_1:       
    while ( true) {
          switch (   (jj_ntk==-1)?jj_ntk():jj_ntk) {
            case OPEN_PAREN:
           case TRU      E_CONST    ANT:
               case FALS  E_CONSTANT:
       case  AN       D_CONS   TA      NT   :
             c a    se OR_C         ONSTANT:
           case XOR       _CONSTANT:
               cas  e NOT_CONSTANT    :
      c          ase EQUIV_CON   STA  NT :
             case IMPL   IES _CONSTANT:
           case FO   RALL_CONST        ANT:
      c   a  se THEREEXIST   S_CO    NSTANT:
      case THEREEXISTEXA   CTLY_CONSTANT:
      case    THER   EEXISTATMOS      T_CONSTA      NT:
          case THEREEXISTAT     LEAST_CONSTANT:
               case EXPANDSUBLFN_CONSTANT:
            case SUBLQU     OTEFN_CONSTANT:
      cas    e TRUE_GUID_CON   ST    ANT:
            case   FALS   E_  G   UID_CO  NSTA   NT:
        cas e AND_GUID     _            CONSTANT:
      case O     R_GUI  D_CONSTA   NT:
      case XOR_GUID_CONSTANT:
                ca     se     NOT_GU      ID_C ONSTANT:
      case EQ    UIV_  GUID_CON     STANT:
         case I        MP    LIES_GUID_CONSTANT:
       case FORALL_GUID_CONSTANT:
      cas      e THEREEXISTS_GUID_C  ONSTANT:
          ca       se THEREEXISTEXACTLY_GUID_CONSTANT   :
      case THEREEXISTATMOST_GUID       _CON S     T  ANT :
        ca     se THEREEX ISTATL  EA   ST_GUID   _CON  STAN  T:
                ca     se E     XPANDS    UBLFN_ GU   ID_CONSTANT:
                   case SUB  LQUOTEFN_GUID     _CONSTA        NT:
          case I NTEGER:
          cas   e      FLOAT:
             case CONSTANT_NAME1:
        case C    ONSTANT_NAM         E2:
           ca  se CONSTANT_GUID:
      case CONSTANT_GUID2:
      case   SIMPL    E_VA  RIABLE:
      case META_VAR      I     AB             LE:
            c    ase STRING:
        ;
        break;
             def    ault:
           jj_la1[0    ] = jj_ge  n;
        break label_1;
            }   
      curTerm = te    rm(  false);
                                            val.add(curTerm);
       }
    eof  (requireEOF);
    {i                f (true) return v          al     ;}
                  throw new Error(    "Missing retu     rn   s       tatement in function"    );
      }

  final public Obje  ct term(boolean requireEOF) throws ParseExcep  t ion,   java.io.IOExcep  tion, UnsupportedVocabul ary      Excepti   on     {
    Object result   = null;
    if (j      j      _    2_1(2  147483647)) {
         result = sentence  (fal  se);
        } else      {
      switch ((jj_   nt k==-1     )?jj_ntk():jj_nt      k)          {
          ca     se TRUE_C  O   NST    ANT:
       case FALSE_CO        N  STANT:
      case AND_CO      NS   TANT:
           cas  e OR   _CONSTANT:         
          cas e XOR_CONSTANT:
      case NOT_CONS    TANT:
      ca     se EQUIV_CONSTANT:
         case      IMPLIES_CONSTAN  T:         
      case FORALL     _  CO NSTANT:
                  case    T HEREE    XISTS_CONSTANT:
         ca       s      e THEREEXISTEXACTLY_CONSTAN   T   :
      case THEREE   X     ISTATMOST_CONSTANT:    
      case THEREE   XIST   ATLEA  ST_     CO NSTA    NT:
      case EXP ANDSUBLFN_    CONSTANT:
           case SUBLQUOTE     FN_CONSTA    NT:
             case TRUE_GUID_C     ONST    ANT:
      case F ALSE_GUID_CON       STANT:       
          ca          se AND_GUID_CONS     TANT:
      case OR_GUID_CONSTANT:
          case X  OR_GUID_CONSTANT:  
                 c    ase NOT  _GUID_CONST   ANT:
      case EQUIV_GUID_CONSTANT:
        c   ase IMPLIES_GU ID_C   ONSTANT:
                    case FORALL_GUID_CONSTANT:
          case    THEREEXISTS_  G  UID_CONSTA       NT:
        case THEREEXISTEXAC TLY_GUID  _CONSTANT:
                case THEREEX I     STATMOST_GU    ID_CO   NSTANT:
              case  THEREEXISTATLEAST_GUID_CON     STA      NT    :
      case EXPANDSUBLFN    _GUID_CONSTANT:    
        c     ase SU  BLQU    OT  EF  N_GUID_CONST     A   NT:
                  case INTEGER:
      case  FLOA     T:
      case CONSTANT_NAME1:
              c    ase     CONSTANT_NAME  2:   
      case C ONSTANT_GUID      :
         case CONSTANT_GUID2:
           case SIMPLE_V       ARIABLE:
       case ME    TA_VARIABLE:
      case   STRI   NG:           
          result = atomicDenota   tionalTerm(false);
          bre    ak;
            default   :
         j     j_la1[1] = jj_gen;
               jj_consume_token(-1);
        throw new     Pars  eException();
                   }          
    }
    eof(requireEOF);
     {    if (     true) return result;}
    thro   w new Error("Mi      ssin     g    return st at   ement in f  unctio   n");
  }

    fi  nal public v      o    id       eof(boolean requi r     eE   OF)    throws ParseExcepti on   {
    if (!requ    ireEO  F) {if (true) r  etur               n;}         
    jj   _consume_token(0);
  }

  final public     CycObject sentenc e(boolean re      quir   eEOF)   throws ParseException, java    .io.    IOEx   ception, Un    sup   po     rte        dVo     ca bularyException {
        CycObject val =  nul        l;
    sw   itch   ((jj_ntk=    =-1 )?jj_ntk():jj_nt         k) {
        c    ase     T  R    UE_CONSTANT:
           c   ase FALSE_CONSTANT:    
    case AND_C   ONSTANT:
           case OR_CONS   TANT:
    case XOR_CONST  ANT       :
    case NOT_     CONSTANT:
    c           as       e EQUIV_CONSTANT:
           case     IMPLIES_CONSTA   NT:
    case    FORAL   L_CONSTANT:
    ca   se THEREEXISTS_   CON STANT:
    ca    se THEREEXISTE    XACT    LY_        CONSTANT:
      ca      se THEREEXIST A  TMOST_CONSTANT:
    case THEREEXI  S   TA   TLEAST_CONST   AN          T:
    case E      XPANDSUBLFN      _       CONSTANT:
                c   ase SUBLQUOTEFN_CO      NSTANT    :
        case TRUE_GUID_CONSTA NT:
        ca se FALSE _GUID_CON     STANT:
    case AND_GUI  D_CO  NSTANT:
    case OR_   GUID_CON          STA NT:
    case XOR_GU  I   D_CONSTANT:
          c    as    e NOT_GUID_C           ONSTANT:
    case EQUIV_G     UID_CONSTAN  T:
     case IMPLI   ES    _GUID_CONSTANT:
    case   FORALL_GUID_CONSTANT:
    cas  e THEREEXISTS_  GU         ID_CON    STANT:
    ca   se THE  REEXIST      EXACTL  Y_GUID_CONSTANT:
    case THER  E  E     XISTATMOST_GUID_CO    NST   ANT:
       cas   e T   HEREEXISTATLEAST_GUID_CONSTANT:
    cas e E           X     P   ANDSUBLFN_GUID_CONSTANT:
        c    ase SUBLQUOTEFN_GUI     D_CONSTAN   T:
    case CONSTANT_   NAME1:
      c      ase     CONSTANT_NAME  2:
    ca    se CONSTANT_GUID  :
    case CONSTAN       T_GUI  D2:
    ca    se SIMPLE             _VAR   IAB LE:
              case META_VARIABLE:
      /*LOOKAH   EAD( < TRUE_CONSTA   NT > | <        TRUE_GUID_CONSTAN     T > | 
                            < FALSE_CO   N   S     TANT > | <      FA  LSE_GUID_CONST    ANT                >         )
          val = co nst    a      nt(f     alse) 
           | val =    v    ariable(   fa lse)*/
                       val = sen   t    ence  D en oting   Rep res   entedTerm(fals e);
      break;
    case OPEN_PAREN:
      j   j      _consume_        token   (OPEN_PA R  EN);
      sw       itch ((jj_ntk==-1)?jj_nt  k():jj_ntk)    {
      case     NOT_CONSTAN   T:
         c      ase NO T_      GUI    D_CONSTANT:       
        val = notFor m(fa lse);
            break;
      case AND_CONSTAN       T:
          ca   se AND_GU   ID_CONST    A    NT:        
        val           = andForm(false);
          br e   ak;
         ca  se      O  R_CONST    ANT      :
         case OR _GUID _CONSTANT:
           val       = orForm(fa    lse);
        br     eak;
      ca se    XOR_CO   NSTANT:
        cas    e  XOR_GUI  D_CONSTANT   :
                         va l =      xorForm(   false     );
              bre      ak;
        c  ase   I MPLI   ES_CONSTANT     :
         case IMP                L        IES    _GUID     _CONSTANT:
           val =        impForm(        false);
        bre  ak;
      ca se EQUIV_C ON   S   TANT:
      case EQUIV _  GUID_C     ONSTANT:
                     val   =   equiv  Form(fa    lse);
            break;
      case FORALL_CONST   AN  T:
        c   ase FOR   ALL  _GUID_CONSTANT  :
        v   al = u   nivForm(  fals       e);  
        break   ;
        case TH   EREEXISTS_CONSTANT:
             case THE  REEXISTS_GUID   _CONSTANT:
            val = existForm(fa       lse);
             b  reak;
          case TH   EREEXISTEXA  CTLY_C    ONST     ANT:
      case        THEREEXISTEXACTLY_GUID_CONSTANT:
               v  al =       existExactF              orm   (false);
                    break;
      case  THERE  EXISTATMOST_C  ONSTANT:     
          case THE    RE  EXISTA         TM OST _GUID_CONS     TANT:  
        val =         ex    istUBoundForm(false)     ;
           break;
                 case T       HER       E      EXISTATL  EAST   _CON             STANT:
        case THEREE      XISTAT     LEAST_GUID_CONSTANT: 
        val = existLB ound F      orm(     false)   ;
               break;
              ca      se    O   PEN_PAREN:
           case TRUE_CONSTANT:  
      case FALSE      _C         ON          STANT    :
        case EX  PANDSUB LFN_    C    ONSTANT:
                case   SUBLQUOTEFN_CONSTANT:
          cas  e TRUE_G   UID_CO      N   STANT:
      case FALSE  _GUID_CONSTAN T:
      case EXPA  NDSUBLFN_GUID_CO   NSTA    NT:
      case  SUBLQ    U   OTEFN  _GUID_CONSTANT:
      case C               ONSTA    NT_NAME1:
      case     CONSTANT_NAME2:
        case CONSTAN    T_GUID     :
      case CONSTANT_GUID2:
          c     ase SIMPLE_VARIABLE: 
      case M ET A_   V     ARIABL E:
        v   al = genericSentence(false);      
        break;
      default:
        jj  _la1[2] = jj_gen;
        jj_c   on s    ume_token(   -1);
        throw  new Pa        rs  eE  xception();
          }
        j               j_c   onsume_token(CLO SE_PAREN    )    ;
         b        reak;
    d    efault:
                           jj_l a1[3] =        j    j_gen  ;
         jj_cons   ume_  tok  en(-1)   ;
          thr     ow   new P  arseEx   ception();
    }
    eof(requir   eEOF)     ;
    {if (true) return val;}    
    throw new Error("M   is     sing   ret   u rn     s  tatement in             function");
        }

  final       public CycList notForm(bool     ean      r  equireEOF) t     hr   ows ParseExcep                tion, j   ava.io. IO     E     xcept ion, UnsupportedVocabular    yEx  ception {
  CycObject se         nt  = n   ull  ; 
          CycLi     st val    = new CycList()  ;
      swi            tch     ((jj_ntk==-1)?jj_n   tk()   :jj_n  t       k) {
      case N   OT_CONS     TANT:
      jj_c     o  n         sume_token(NO    T_CONSTAN   T);
         break;
        case   NOT_G         UID_CONSTANT:
      jj_consume_          to   ken(NOT_GUID_CONSTA   NT);
           break;       
    d    efault:
                jj_la1[4]    =  jj_gen;
      j     j_co    nsume_    token  (-1);     
      throw new     Pa  rseExcepti  on();
        }
                                                                                                   val.  add(       ge     tCycAccess( ).not);  
    s   ent      = sen          tence(f         alse);
                                 va  l.add  (s      ent);
    eof(require  E  OF)  ; 
       {i  f (t     rue) return val;}
     t     h row new Error("Mi         ss   ing        return stateme    nt in fu  n  ction");
  }

  final public C        ycList andFo      rm(boolean       req     uireEOF       ) thr  ows ParseException, java.io.IOExc  eption, Uns   upportedVocabulary      Exc  eptio  n  {
    CycList s          entences = n      ull;    
  CycList val = n       ew          CycL    is   t();
         switch ((jj_                ntk=        = -1)?jj_ntk(  ):jj_ntk)     {
    case  AND_CONS TANT:
                jj   _cons        ume_token(A    ND_    CONSTA  N T   );
       brea   k  ;
        case AND_GUI  D_CO    NSTANT  :
      jj_consume_token        (   AND   _  GUI  D_CONSTANT);
      break;  
      d  efault:
       jj_la1[ 5] =    jj      _gen;
      jj_c         onsum   e_token(-      1);    
      th      row new ParseExcepti  on();
       }
                                                                                v  a  l.add(getCy     cAccess()   .and);
    sentences = sentence      List(false) ;
                                                       if  (s  ente   nces != null) { val.addAll(se    ntences); }     
         eof(requi    reEOF );
    {i  f (    true) re      t       urn val;}
    th  ro      w n     ew Erro   r           ("Missing return statement in fu   nction"    );
  }

  final  public CycList orForm(bo olean requireEOF) thro        ws Pa  rs     eExcept  ion, java.io.IO    E      x     ception, Un        s   upportedVocabulary Exception {
  CycLi      s   t sen                ten     ces = null;     
    CycList v   al       =   new CycLis      t();
        switch ((jj_ntk==  -1)?j                j_ntk():jj_ntk) {
    case OR_CO    NSTANT:
      jj_consum    e     _    toke  n(O            R_CONSTANT);
                   break    ;
         case              OR_GUI  D_C              ONSTANT:
      jj_consume_ token(OR _GU    ID_CONSTANT  );
      break;
    d            efaul  t:
           jj_la1[6] =   j    j_gen    ;
      jj_co      nsume_t   o   ken         (-1);
      t     hrow n    ew ParseExcept ion       ();
        }
                                                                                   val.   add(get     CycAcce  ss().or);
    se       ntences    = se   ntenceList(false);
                                                                  if (   sentenc   es != n     ul    l) { val   .addAll(sentenc    es); }
    eof  (requ   ireEOF);
            {if (     true) retur  n    val;}
       throw new      Err o r("Miss       ing        re         tur     n stat   ement in       func   tion")    ;
  }

  final publ    i  c CycLi       s    t  xorForm(b   oolean requireEO    F)     t hr   ow     s        ParseExcepti  o  n, java.io            .IOExc   e ption, Unsupport   edVocabularyException {
  CycObject sent          =   n   ull; 
  CycObj    ect sent2 = nu    ll;     
  Cyc  List val    = new CycList(  );   
    swit     ch ((jj_ntk==  -1) ?jj   _ntk  ():jj_ntk) {
       case XOR_CONSTAN     T:
      jj_con    s  ume_t    oken(XO R_CONST        A        NT);
            br    eak;
     case XO   R_GUID_   CONSTANT:
             jj_consume_t oken    (XOR_G  UID_CONST  AN  T);
      break;
     d   efault:
              jj_  l  a1[7] = jj_ge     n;
       jj_    c          onsume_token(-1);   
                       throw new    Pa  r s    e   Exception();
       }
                                                                               val.add(   g etCycAcc    ess().xorCo    nst);
             sent = se ntence(fa     l          se);
                                                  va   l.add(se   nt);
              s     ent2     = sente nce(false);
                                       val.add(sent 2)  ;
          eof(requi   reEOF);
    {if (t      rue)     return      val;}
    t  hrow new Error( "Mis  sing return statement i   n       funct  ion") ;
         }

  final pub        lic CycLi    s       t imp  Fo    rm(b  o  olean requir  eEO   F) t  h      row    s P     arseException, java.io.IOExcepti on, UnsupportedVocabularyExc      e    ption {   
  CycObject sent   = null;
  CycObjec t sent2 =    n ull  ;
  CycLi st val =      new CycL ist();
       swi     tch ((jj_ntk   ==-1)?j  j_ntk   ():jj_ntk) {
             case       IMPLIES_CONSTANT:
                     jj_consume_toke         n(IM   P       LIES_CONSTANT   );
      br  eak;
    case IMPLIES_G   UID_   CONSTANT :
      j  j_consume_token(IMPLIES_G  UI D_C      ONS    TAN  T);
       break; 
    def ault:
      jj_  la1[8]    = jj    _gen;
              jj_cons u    me_toke    n(-1);
                t    hr                    ow new ParseException();
            }
                                                                                               val.add(getCycAcce    ss    ().impli   e  sConst);
    sent = sentence(       false);
                                    v al.add(sen    t);
    sent2 = s entence  (fa lse);
                                        val.a   dd(sent   2);
    eo f(requireEOF);      
       {if (true) return   v                a           l;}
    t         hrow new Erro     r("Missing      return s      t   atement in function");
  }

  f  i    nal        public   CycList equivF   o    rm(boo   lean re  quireEOF) throw   s ParseExc   eption, java.io  .IOException, UnsupportedVocabular    yException {
     CycObjec       t se  nt = nu        ll;
              CycObject sent2 = null;               
  CycLis  t val       =   ne      w C   ycL    ist(   );   
             s   wi     tc   h ((jj_ntk==-    1)?jj   _ntk():    jj_ntk) {
    case EQUIV_CONSTANT:
      j    j _consume_token  (EQ  UI    V_CONSTANT);
        break;
    case EQUIV_GUID_CONSTAN    T:
      jj_co  nsume_token(E           QU      IV_G  UID    _CONSTAN       T);
                                    break                 ;
         d  efault:
        jj_  la1[9] = j   j_gen;
       jj_consume_token (-1);
      t  hrow new     ParseExcepti      on();
        }
                                                                  val.ad d(                   getCycAc       ces  s( ).equiv  Const  );
      sent =      sente  nce(fa  lse);
                                                               val.     add(sent);
      sent2 = sen      t   enc   e     (fa       lse);
                                           val.add(sent2);
    eof(requireEOF);  
         {if (t        rue    ) return v   al;}
    throw ne       w E   rr                   or  ("Mis    s      ing     ret    urn statement     in function");
  }

  fin      al public CycList univForm(boolean r  equireEOF)  th r             o         ws    Par   seExcept ion, java.io.I   O Except  io      n,           UnsupportedVocabularyException {
  CycObje    c      t var = null;
           CycObject se   n  t = null  ;
  C  ycList val = new CycList();
      switch ((j   j_ntk==-1)?jj_ntk   (     ):jj_ntk) {
       case FORALL_CONSTAN     T:
                 jj     _consume_token   (FORALL_CON    STANT);
           br   ea   k;  
      case FORAL   L  _GUID_CONSTANT:
      jj_consum     e_token(FORA   LL_     GUID    _  CONSTANT);
      break;
     def   ault:
          jj_la1[10] = jj_ge           n;
       jj    _consum     e      _ token(-1)  ;
        t    hrow ne  w     ParseException();
    }
                                                                     val.ad           d(getC  y  cAccess().forAllConst);    
    var  =    variabl   e(   false);
                                                  val.add(var);
    sent =  sentence(false      )     ;
                                     val.add(sent);
    e o  f(requireE         OF);
    {if (true) ret         urn             val;      }
    throw new  Error("Missing return s    tatement in funct   ion"  );
      }

  final   public CycList e    xistForm(boolean     requ   ireEOF) thr ows ParseException, ja    va.   io         .IOEx  ce        ption,         Unsu   pportedVocabularyException {
  C                ycVariable var = null;
  CycObject s     ent = null;
   C      ycList va   l = ne w CycList();   
                  s witch ((jj_ntk==-1)?jj_ntk():jj_nt k)    {
    c  ase THEREEX    ISTS_CO      NSTANT:
        jj_cons               ume_toke   n(TH ER     EEXISTS_CONST   ANT);
                bre    ak;
    case   THE      REEXI STS    _GUID_CONSTANT         :
          jj_consume_token(THERE         EXISTS_GUID_CONSTA  NT);
             b  reak;
    default:
      j   j    _ la1[11     ] = jj_ge    n;
      jj_c    onsume_      to ken(-1);
      throw new ParseException();
      }      
                                                                                                          val.add(getCycA    ccess().thereExists   Const);      
    var = variable(fal             se);
                                   val.add    (var);
    sent    = senten   ce(f   als   e);
                                       val.add(se    nt);
              eof(requi   reEO   F      );
    {if (true) return     v      al     ;}
    th   row new E     rror("Missing return state  men    t            i      n function");
  }

  final public CycObjec  t existExactFor  m(bo     ol     ean requi    reEO   F) thr   ows     Par  seException, java.  io      .IOExcep   tion, Unsupp   or     te            dVocabularyException              {
  CycVariab  le var =        nu  ll;
  CycObject sent = null;
  CycList val = new C       ycList();
    switch ((jj_nt k==-1)?jj_ntk():        jj_ntk)     {
        cas   e THEREEXI    STEXA   CTLY              _CONSTANT:
          jj_co nsume_token(TH    ERE EXISTEXACTLY       _CONSTANT);
      break;
       case TH           EREE    X     ISTEXA     CTLY_   GU   ID_CO  NST    ANT:
      jj_consume_token(THEREEXISTEXA    CTL         Y_GUID_     CO       NSTANT);
      brea   k;   
          default:
      jj_la1[12]    = jj_gen;
            jj   _consume_tok   en(-1);
      throw new ParseException       ();     
                   }
                                                                                                                                   va   l.add(getCycA  cc   ess().thereExistExactl   yConst   );  
              var = vari       ab  le(fal    se);
                                           val.add(var);
    s        ent     = se nt ence    (false)  ;
                                 val    .add(sent);
    eof(re  quireE      O F);
    {i    f (    true) ret   urn val;}     
    throw new Error("Missing return    statement in function");
  }

  fin      al   public CycList existUB   oundFor  m(boolean      requireEOF) throws ParseException, jav       a.  io.IOException, UnsupportedVoc   a    bularyExc    eption {
  CycV   aria   ble     var  = nu      ll;
  CycObje    ct sent = n        ul      l;
    CycList      va     l = ne w C    ycList();
     switch ((jj    _ntk  ==-1)?jj_n tk():jj _  ntk)   {
    case       THEREEXIST        ATMOST_CONSTA           NT:
      jj_cons   um e_token(THEREEXISTATMOST_CONSTANT  );
      bre  ak;
         cas e THEREEXISTAT   M    OST_   GUID_CON   STANT:
      jj_consume_token(TH    EREE   XISTATMOST_GUID_CONSTAN     T);
      bre   ak    ;
    def    ault:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      th    r   ow ne  w ParseE xcep   tion( );
    }
                                                                                                              val.add(getCy          cAc    cess(    ).thereExi     st  AtMostCo     nst);
             var = varia      ble(false);
                              val.  add(var);
    sent =     sentence(false);
                                    val.    add(sent )  ;
    e of(requir    eEOF);
        { if   (true) re turn   val;}
          thr    ow new Error("M    issin    g return statement in f  unction");
  }

  final public CycList ex  i       st     LBoundForm(boole an require  EO F) t   hro      ws ParseException, java.io.IOEx   ception, Unsuppo   rtedVocabularyException {
  CycVariab   le var = null;
  CycObject sen       t = nu  ll;
  CycL ist val =    n     ew CycList     ()  ;
      switch ((jj_n         tk==-1)?j     j_ntk    ():j         j_n  tk) {
    cas     e THEREEXISTATLEAST_C    ONSTANT:
         jj_consume_token(THEREEX ISTATLEAST_CO   NSTAN   T);
      break;
        case THEREEXISTATLEAST_   GU   ID_CONSTANT:
      jj     _        consume_token     (T   HEREEXI   STATL    EAST_G     UI D_  CON  STANT);
               break;
    defa  ult:
      jj_la1[14       ] = j    j_gen;   
      jj_        consume_ token(-1);
                t     hrow new Pa  rseEx   ception();
    }
                                                                                                    val.add(getCycAccess().thereEx   istAtLeas   tCons     t);
       var = variable(      fal se);
                                 val.add(v  ar)      ;
    s   e    nt =  sentence(fal  se);
                                  val   .add(sent);  
       eo  f   (requireEOF);
    {if (t   rue) r    eturn v  al;  }
         throw new Error(  "Missing retur  n statemen     t in   funct              ion");
                }

    final public CycList genericSe    ntence    (    boo l  ean requireE OF)    throws ParseException   ,   ja             va.io.I  OException, Unsu   pported   V      ocabularyException {
  Cy cObject pred = null;
  Cy     c  List arg  s = null;
    pre    d = p       redicate(fals   e);
    args = argumentLis                  t(false);  
                                   args.ad d(0, pred);
       eof(requireEOF);
    {if (true        ) retu     r       n args;}
    throw        new    Error(" Missing return statement in function");
            }

  f    ina      l public CycList se         ntenceList  (    boolea    n requireEOF   ) thr    ows Pars          eException, java.    io.IOException,   Un           sup           portedVocabul  aryExc   eption        {
  Cy     cObject sen        t = null;
  CycVar               iable va     r = nu  ll;
  CycList resu   lt = ne       w CycLi      st();
    labe   l_2:
     while (true)     {
      swi    tch ((j  j_ntk==    -  1)?jj_ntk():jj_ntk) {
      cas      e    O      PEN_    PAREN:
          case TRUE_  CONS  TANT:
      cas     e F        ALSE_CONSTANT:
            case AND_    CONSTANT:    
      case OR_CONSTA     NT:
              case XOR_CONSTANT:
              case NOT_CONST    A     NT:
                 case EQ        UIV_C    ONSTANT:
          case IM          PLIES_CONS    TANT:
      case FORALL_   CONSTANT:
        c  a  se THEREEXISTS_CONSTA  NT:
      cas e THEREEXISTE   XA     CT  LY_CONSTANT:
      case THEREEXISTATMOST_CONST   ANT:
           case   THEREEXISTATLEAST_CONST            ANT:
      case EXP   ANDSUBLFN_CONSTANT:
      case SUBLQUOTEF               N_CONSTANT:
                  case  TRUE_GUID_CON STANT:
      case F  AL      SE_GUID_CONSTANT:
          cas    e AND_GUI   D_CONSTANT:
        case     OR_GUID         _C    ONSTANT:
      case XOR_  GUID_CONSTANT:   
      case NOT_GUID_CONSTANT        :
        case           EQUI  V_GUID_CONSTANT:
      case                IMPLIES_GUID_CONS TANT:
      c        ase FORALL_      GUID_CONSTANT:
       ca  se THEREE   XI  STS_GUI    D_CONSTANT:     
       case THEREEXISTEXACT  LY_GUID_ CONSTANT:
      case THE  REEXISTATMO   ST_GUID_CONSTANT:
          case     THEREE      XISTATLEAST_GU      I  D_ CONSTANT:
      case EXPAN D   SUB    LFN_GUID      _CONSTANT:
      case SUB   LQUOTEFN  _GUID_CONSTA     NT:
                  c  ase CONSTANT_NAME1:
        case CONSTANT    _ NAME2:
        case CON   S     T  ANT_GUID:
              case CONSTANT_GUID2     :
      case   SIM      PLE_VARIABLE:
      case META_VARIABLE:
        ;
        break;
      default:
         jj_la1[15]  = jj_gen;
        break    label_2;
         }
      sent = sentence       (false);
                                                   result.add(  sent);
         }
             sw  it     ch ((jj_ntk=  =    -1)?jj       _ntk():jj_nt       k)   {
    case 78:
           j     j_co  ns      ume_    token(78);
      var = variable(false   );
      break;
    default:
             jj_la1[1         6] = jj_ gen;
              ;
        }
    eof(requir    eE    OF);
           if      (var !=             null) { result.setDo ttedElement(var); }
    if (result.size() == 0 ) { result = nul       l; }
    {     if (tru    e) re      turn result;}
     throw      new Error("Missing return   s    tatement in function" );
  }

  final pub   lic  CycLis      t       argumentList(boole   an requireE OF) throws ParseExceptio     n    , java.io.IO      Exception, UnsupportedVoc    ab        ula   ryExc      eptio   n {
  Object   curTerm = null;
  CycV a riable va        r = null;
  CycList        r   esult = new CycList();
    label    _3:
    while (true) {
            swi tch ((jj_ntk==             -1)     ?jj_ntk   ():jj_ntk) {
      ca   se O PEN_PAREN:
        case TRUE_CONSTANT:
      c as                      e FALSE_CONSTANT:   
                   case AND_CONSTANT:
        case OR_CONSTAN   T:         
          ca     se XOR_CONSTANT:
       case      NOT_CONSTA  NT:
      case EQUIV_CONSTANT:
      case IMPLIES_CONSTANT:
                     c   as  e FO  RALL_C    ONSTANT:
          c   ase TH    EREEXISTS_CONSTANT:
        case THEREE XISTEXACTLY_CONSTANT:
      case THEREEXISTATM   OS   T_CONSTAN  T:
      cas e THE   REEXISTATL     EAS T_CONSTANT: 
       case EXPA             NDSUBL FN_CONSTANT:          
      case SUBLQUOTEF     N          _CONSTANT:
        c      ase T            RUE_GUID_CON  STANT:
           case FALSE_GUID_CONSTANT:
      case AND_GUID_CONS        TANT:
      case OR_GUID_CONST ANT:
      case XOR_G        UID_CO    NSTANT:
      case NOT_GUID_C   O NSTA        NT:      
      case EQUIV_GUI     D _CONSTANT:
            case IMP    LIES  _G                UID_CO               NSTANT:
      case FOR   ALL_GUID_CO  NS     TANT:
            ca   se    TH  EREEXISTS_ GUID_CONSTANT:
           ca   se THEREEXISTEXACTL   Y_GUID_CONSTANT:
             case THEREEXISTATMOST_GUID_CONSTA NT:
      case         THEREEXIST    ATLE  AST_GUI D_CONSTANT:
      case EXPANDSUBLFN_GUID_CONSTANT:  
          case SUBLQUOTEFN_GUID_CONSTANT:
             case INTEGER  :
            case FLOA T:
        case CONSTANT_NAME1:
      case  CONSTANT_NAME2         :
      case CONS  TANT_GUID:
      case CONSTANT_GUID2:
                case SIMPLE_VARIABLE:
         cas e META_VARIABLE:
         case ST  RING:      
         ;
             break;
            default:
              jj_la1[17] =    jj_g   en;
        brea         k label_3;
            }
            cu  rTerm = term(false);
                                        resul   t.add(curTerm);
       }
    switch ((jj_ntk==  -1)?    jj   _ntk():jj_ntk)  {
       case 78:
        jj_consume_token(78);
         var =    variable(false);    
      break;  
    default    :
        jj_la1[18] = jj_gen;
      ;
        }
    eof(requireEOF);
    if (var != null) { re   sult.setDot  tedEl              e   ment(var); }   
    {if (true  )    ret    urn result  ;    }
    throw n   ew Error("M issi     ng return sta    te      ment       in fun     ction");
   }

   final pu    blic CycObject predicate(boo     lean requireEOF)        throws Pa     rseException, java.io.IOException, U nsupportedVocabularyExcep   t     ion {
  Cy   cObject t = null   ;
         t = represent  edTerm(fal  se);
    eof(req    uireE OF);
    {if (true)      ret    urn           t;}
         th row n    ew Er      ro     r("Missing return statemen      t in function   ");   
       }

  final public CycOb  ject se   n      tenceDenoting Represen    tedTerm(boole   an requireEOF) throws  ParseExcep   tion, java.io.IOException, UnsupportedVoc  abularyException    {
  CycObject val = null;
    val = atomi   cSenten   ceDenotingRepresented           Term(  fa lse  );          
    eo              f(requireEOF);
    {if (true) return val;}  
    th    row ne w Error("Mi    ssing return         statement in func    t io  n")   ;    
     }

  fi   nal public            CycList no  nAtomic      SentenceDenotingDenotationalT   erm(boole  a n requireEOF) t     hrows ParseExcepti  on, java.  i  o.IOExcep     tion, UnsupportedVocabularyE   xception {
    CycList val;
     val =      nonAtomicDenotationalTerm(fals    e);
     eof(requireEOF);
    {i f (true)      return val;}
    throw   new Error("Missin    g return stateme   nt in function");
  }

  final pub lic CycObject represe     nte      dTerm(boolean req  uireEOF) throws ParseException, java.io.I     OEx          ception, UnsupportedVocabularyException {
        CycObj   ect val = null;
    switc    h    ((jj_n   tk ==  -1)?jj  _ntk():jj_nt        k) {
      ca   se TRUE_CON  STANT:
     case FA  LSE_CONSTANT:
    case AND_CONSTAN   T:
    case OR_     CONSTANT:
    case   XOR_CONSTANT:
    case NOT_CONSTANT:
        case EQUIV_CON  STANT:
          case IMPLIE   S_    CONSTA NT:
    c    ase FORALL_CONSTANT:
    case   THEREEXISTS_CONST    ANT:
    case THEREEXI    STEXACTLY_CONSTANT:
          case THEREEX     ISTATMOS  T_CONSTANT:    
      c  ase   THE  REEXISTATLE AST_CONSTANT:
    case EX     PANDSUBLFN_CONSTANT:
     case SUBLQUOTEFN_              CONSTANT:
        case TRUE_GUID_CONSTANT:
    case      FALS E_GUID_C   ONSTANT:
        case AND_  GUID_      CONSTANT:  
    case   OR_GU  ID_CONSTANT:
    case XOR_GUID_CO     N    STANT:
       case NOT_GUID_CONSTA       NT:
    case EQUIV_   GUID _CON  STANT:
    case IMPLIES_GUID_CONSTAN   T:
    cas e FORALL_GUID_CO NSTAN    T:
    case THER     EEXIS  TS_GUID_CONS      TANT:         
    case    THER  EEXISTEXACTLY_GUID_CONSTANT:  
    case THE  RE  EXISTATMOST_GUID_CONSTANT:
    case THEREEXISTATLEAST_   GUID_CO NSTANT:     
    case EX    PA   NDS    UBLFN_GUID_CON    STANT:
    case SU B LQU    OTEFN_   GUID_  CONSTANT:
    case CONSTANT_NA    ME1:
    case CON         STANT_     NAME2:
    case CONSTANT_GUID:
             case C   ONSTANT _GUID2:
      c    a    se SIMPLE_VARIABL  E: 
    case META_ VAR      IAB    L E:
      val = atomicRe p  r      e  se nte   dTerm(false);
         break;
    case  OPEN_PAREN:
       val =  nonAtomicDenot  ationalTerm(false);    
       break;
         default:
         jj_la1[19] = jj_gen;
         jj_consume_   to  k   en(-1);
      thro        w new ParseException();
    }
    eof(requireE    OF);
           {if  (true) return val;}
    thr   ow n e  w  Error("   Missin   g r            eturn statem   ent in function");
  }

  f inal public CycList nonAtomicDenotationalTerm   (    b       oolean requireEOF)  throws    ParseExcep  tion, j  ava.io.IOE xcepti    on, Unsupporte  dVoca  bulary     Exception {
  Cy   cObject func;
  CycL      ist args;
    jj_consume_to ken(OPEN_PAREN   );
     func = func       tion(false)  ;
    a   rgs = argument    List(false);
    jj_consume_token(CLOSE_PAREN);
    eof( requireE   OF);
    args.add(0, func);
    {if (true)     return    args;}
    throw new Error("Miss  ing return st   atement in function    ");
            }
 
  fina  l publ   ic CycObject function(  bool     ean requireEO  F)  throws ParseException, java.io.IOException, UnsupportedVo   cabularyEx  ceptio       n {
  CycObject val =    null;
          val = repre       sentedTer  m(      false);
    eof(requireEOF);
    {if (true) return       v    al;}
               throw   new Er ror("Mi     ssi      ng return    stateme    nt in function");
  }
   
  final public Ob ject denotational     Term(b   oolean re    q      uireEOF) throws ParseException, java.io.I OExcept  ion, UnsupportedVoca bular yExcep   tion       {
  Ob          ject val = null;
         switch ((jj_ntk=   =-1)?jj_  ntk       ():jj_ntk)     {
       case TRU    E_CONSTANT:
    c    ase FALSE_CONSTANT:
          case AN   D_CON     STANT:
    c  ase  OR_CONSTANT:
        case XOR  _CONSTANT:
              cas  e NOT   _CON     ST    AN     T:
      c ase EQUI   V_C ONSTAN  T:
    case IMPLIES_CONS    T    ANT:
    case FORALL_CONSTANT:
    c   ase T   HEREEXISTS_CONSTANT:
    case THEREEXISTEXACTLY_CONSTANT:
        case THEREEXISTATMOST_CONS  TANT:
             case T HEREEXISTATLEAST_CONSTANT:
    case EXPANDSUBLFN_CONSTA    N    T:
        case SUBLQU       OTEFN    _C          ONSTANT  :
    case   TRUE_GUI  D_CONSTANT  :  
    case   FALSE _GUID_CO NSTANT:
          case AND    _GUID_CONST     ANT:
    ca    se OR_G   UID_CON      STANT:
    case XOR     _GUID_C  ONSTA       NT:
     case NOT_GUID_CO    NSTANT:
    case EQUI    V_G     UI   D   _CONSTANT:
      case I    MPLIES_GUID_CONSTANT:
    cas            e FORAL L_GUID_  CONSTAN   T:
    case TH ERE    EXISTS_GUID_CO    NSTANT:
    case T      HERE    EXISTEX  A  CTLY_GUID_CONST               ANT:
    ca   se THEREEXISTATM OST_GUID_CONSTANT :
             c   ase THEREEXI                STATLEAS T_GUI     D     _CONST   ANT:
             case EXP     ANDSUBLFN_   GUID_CONSTANT:
      case SUBLQUOTEF      N_G     U   ID_CONSTANT:
    case         INTEGER:
    case   FLOAT:
    case CO  NSTANT_NAME1:  
    case    CONSTANT_N  AM       E2   :
    case CONSTANT_           GUID:
    case CONSTANT_GUID2 :
         case     SIMPLE_VARIABLE:
    ca   se   ME      TA_VARIAB   LE:
        case ST  RING:
      val = atomi   cDenot  ationalTerm(false);
                       break;
    case O  PE    N_PAREN:
             va    l = n       onAtomicDenotati   on  alTer  m(f     alse);
      b              rea  k;
        d   e    fault:
      jj_  la1[2     0] = jj_ge  n;
      jj  _consume_token(-1);      
        throw    new ParseExcep     tion();
      }
     eof(   requireEOF);
    {if  (true) return v     al;}
          throw       new Error("Missing  return statement in function"     );
  }
   
///// Deal with ato ms
    fi    nal public   Object atomicD enotationalTerm(boolea   n requireE OF) throws ParseException, j    ava.io.IOException, Unsupporte     dVocabulary     Except   ion {
  Ob ject r esult = null ;
    switch ((jj_ntk==-       1)?jj   _ntk   (     ):jj     _ntk) {
    case TR   UE_C  ONSTANT:
    c ase FA    LS    E_CONSTANT:
     case         AN     D_C      ONSTANT  :
    case OR_CONSTANT:
    case XOR_CONSTANT:
    case  NOT_CON                STANT:
    case EQ     UIV       _CONSTANT:
    c ase IMPLIES_CONSTAN    T:
    case FORALL      _CO      NSTANT:   
    case THEREEX     ISTS_CONST         AN    T:   
    case THEREEXI      STEXACTLY_CONS TAN    T:
    ca  se THER EEXISTAT     MOST_CONSTANT:
    ca  s    e THEREEXISTATLEAS T_CONSTAN      T:
               case EXPANDSU BL          FN_CONSTANT:
       c   a     se   S  UBLQUOTEFN_     CONSTANT:
    c ase TRUE_GUID_CONSTA    NT:
           case FALSE_GUID_CONSTANT:
       case AND_GUID_CON STANT:
    case  OR_GUID_CONSTA       NT     :
    case XOR          _GUI D_CONSTANT:
         ca se NOT_GUID_CONSTANT:
        c  ase EQUIV_GUID_CON     STANT    :
    case IMPLIES_GUID_       CONS   T  ANT:
     case FORALL_GUID_CONSTA  N  T:
    case THEREEXISTS_GUID_CONSTAN  T:
    case THEREE XISTEXACTLY_GUID_CONSTA NT:
       case THER         EEXISTATMOST_G     UID_C  ONSTANT:
    case THEREEX    IST                      ATLEAST_GUI D_CONSTANT:
    c       ase   EXPANDSUBLF         N_GUID_CONSTANT:
    c       ase SUBLQUOTEFN_GUID_CON     STANT:
    case CONS    TANT_NAME1:
    case CONSTAN       T_NAME2:
    c ase          C    ONSTA    NT_GUID:
            c      ase CONSTANT_G     U      ID2:
    case SIM           PLE_VAR    IABL    E     :
         case META_VARIABLE:
      result = atomicR     epresentedTerm(false);
       break;
      case INTEGER:
     case FLO  A       T     :
    case STRING:
            result =   literal(false);
      break;
           defau     lt:
        j  j  _l     a1[21]   = jj_gen;
        jj_    consume_toke  n(-1 );
          th ro       w     n              e        w ParseEx  ception();
        }
          eof(requireE  OF);
    {if (tru   e) return            result;}
      throw new Error("M  issing return st      atement in  function");
  }

  final public Cy    c    Obj    e   ct atomicSentenceD         enoting  Repres    entedTerm(b oolean requireEOF) th    rows Par  seException, java.   io.IOExce  pt    ion, Uns     uppor   te   dVocabularyException {
     CycObject val = null;
            switch ((jj_ntk      ==-1)?jj_ntk():jj_ntk) {
      case TRU         E_CON     STANT:
     case FALS       E_CONSTANT:
    c  ase AND_  CONSTANT:
          case OR_CONSTA  NT:
           case XOR _CONSTAN  T:
    c       ase     NOT     _CONSTANT:
                     case EQ    U       IV_C   ONSTANT:
       case IMPLIE          S_CONSTANT:   
      c  ase FOR   ALL_C  O        NSTANT:
    case THEREEXISTS_CO NST  A NT:
    case THEREEXISTEXACT   LY_CONSTANT:
    case THEREEXIST               ATMOST_CONSTANT:
    c    ase THEREEXISTATL EAS T       _CONSTANT:
      case EXPAN  DSUBLFN_CONSTANT:
    case SUBLQUOTEFN_CONSTANT:
    case TRUE _G      UID_CONSTANT:
    case FALSE_GUID_CONSTANT:
        case AND_GUID_CONSTANT   :   
       c  a     se    OR  _GUID_         C  ONSTANT :
    ca   se XO     R      _G   UID_CONSTANT:
    ca    se NOT_   GUID_CONSTANT:
     c    ase    E     QU IV_G  UID_CONSTANT:
    ca    se   IMPLIE  S_GUID_CONST ANT:
    case FORALL_GUID_CONSTA     NT:
    ca  se     THEREEXISTS_GU              I        D_CONSTANT:
    case THE   REEXISTE  XA      CTLY_GUID_CONSTANT:
    case THEREEXISTATM        OS   T_GUID_CONSTANT:
    case THER  EEXISTATLEAST_GUID  _   CONSTAN        T:   
     ca  se EXPAN     DSUBL     FN   _GUID_CONSTANT: 
       case SU     BLQUOTEFN_GUID_CO  NSTANT:
       case CONSTANT_NAME1:
    case CONSTA  NT_NAME2:
    case CONST   ANT_GUI  D:   
       case CONSTANT_GUID2:
       val =         sen  tenceD  e notingConstant(false)               ;
          bre   ak;
    cas e SIMPLE_VARI  ABLE:
     cas     e   ME        T   A_VARIABLE:
      val   = sentenceDenotingV aria     ble(false);
        break;
    default:
      jj_l a1[22] = jj_ge   n;
                jj_con     sume_token(-1);
      throw n   ew ParseException();
    }
    eof(r    equir   e            EO  F);
    {i   f (true) return val;}
     throw     new Error("Missing retur   n statement in    function");
  }

  final pub      lic CycObjec   t atomicRe      presentedTerm(bool  e      an req    uireEOF) throws ParseException,      java.io         .IOExcept      ion, UnsupportedVo    cab    ular    yExcept      ion {
  CycObject        val = nu  ll    ;
    swi    tch ((jj_nt   k==-1)?jj     _ntk  ()        :jj_  ntk )          {
             case T       RUE_CO        NST AN    T: 
            case F     ALS  E_           CO          N          STANT:
    case AN    D_CONSTAN  T:      
    case OR_CONSTANT:
    case      XOR_CONSTAN    T:    
           case NOT_CONSTA        NT:
    case EQUIV_CON    S  TANT:
    case IMPLIES_CONSTAN         T:
                  case FORA   LL_CONSTANT  :
    case T         HEREEXIS    TS_CONSTANT:
         case THEREE   XISTEXACTLY_CO  NSTANT:
    cas  e THEREEXI  STATMO                       ST_CONST  A NT:
       cas    e TH    EREEX     ISTATLEAST_CONSTANT   :
          case EXPANDSUBL  FN_CONST    ANT:
    case S  UBLQUOTEFN_CONSTANT:      
    case     TRUE_GUID_CONSTAN    T :
             c    ase F ALSE_  GU      ID_CONSTANT:
      case A  ND_GUID_CONSTANT:
    c     as        e OR_GUID_CONS   TANT:
          case  XOR_GUID_CO   NSTANT:
    case NOT_GUID_CO     NST    A    NT:
    case EQUIV_GUID_CON        STANT:
           case        I    MPLIES_GU    ID_CON   STA N  T:
    case      FORALL_    G   UID_CO    NSTANT:
    case THEREEXIST      S_GUID_CONSTANT:
    c   ase THE    REEX I    STEXACTLY_GUID_CONSTANT:
    case THEREEXISTATMOST_G UID_CO   N  STANT:
                 case     THEREEXISTATLEAST_GUID_CONSTANT:
    case EXPANDSU    BLFN_GUID_C             ONS T A      NT:
    case SUBL     QU   OTEFN_GUID_CONSTAN   T  :
    case CO  NSTANT_NAME1:   
    ca    s     e   CONSTANT   _NAME2:
       case CONSTANT_GUID:
      case CONSTANT_GUID2:
               val =   consta   nt(false);
         break;
    c   ase SIMPLE_VARIA        BLE  :
                         case ME  TA_VARIABLE:
         val   =   vari    ab l   e(false);
                  break;
          default:
              jj_la1[23] = jj_g  en      ;
      jj _cons um        e_token(-1)    ;
      t   hro     w new ParseExcep    tion();
              }
         eof(requireEOF     );
    {if (true) retur            n val;}
    throw          new Error("M   iss  ing      return statement   i n fu  nction");
   }

  fin    al publi       c Objec    t literal(boolean r     e    q  uireEOF) thro  ws ParseExce ption, java     .io.IOE    xception {
  Obje        ct v al = null   ;
    switch            ((jj_ntk==   -     1)?  jj _n        tk(   ):jj_ntk) {
    case   S        TRING:
       val =     s  tring(false); 
        b  reak;
        case INTEGER:
    cas   e FLOAT:
        val =  numb    er(false);
              break;
          default:
      jj_l a1[24] = j     j_        gen;
                       jj_consume_token(   -1);
                        throw n   ew ParseException();
    }
    eo     f(requ  ireEOF);
         {if   (tru   e) r   etur     n val;   }
      throw n   ew Error("M       i            ssing retu        rn st ateme    nt in functio     n");
  }

  final pub      lic CycCon  st         an t sentenceD    enotin gCo   nstant(boo   lea n requireEOF)   thro  ws Parse    Ex               ception     ,      java.io.IOException, U nsu pp  ortedVocabulary        Excepti  on  {
         CycConst      ant val = null;
    val   =      constant(false);
      eof(requireEOF);
    {if (true)    return val;}
        throw new  Error("    Missing return s       tatem    e       nt in function");
  }

     fin   al  public CycConstant constant(boolean requireEOF) th r ows ParseE  xcep     tion,   java.io.IOException, Unsuppor     tedVocab      ul   a   ry    Exception {
  C yc           Consta   nt val = null;
   Token t = null    ;
    switch ((j  j_ntk==-1)?   jj_ntk():jj_ ntk) {
    case T  RU     E_CONSTANT:       
    case FA  LS E_CONSTAN         T:
           case AND      _CONSTANT :
    ca  se OR           _C      ONST     A    NT:
      case   XOR _CON  STA           NT:
       case NOT     _CONS   TANT:
    case   EQUIV_CONSTAN  T:
    ca  se         IMPLIES_CO    NSTANT      :
    case  FORALL_CONSTANT:
    case THE    RE   EXISTS_CON  STAN    T:
       case THER     EEXISTEXA              CT        LY    _CONSTANT:            
             case THERE   EXISTATMOST_CONS     TANT :
    case    T       HEREEXISTATLEAST_CONS  TANT:
    case EXPAND        S    UBLFN     _CONSTANT    :
    c a se S UBLQUOT EFN_CONST  ANT:
         case TRU       E_ GUID_CONSTANT:          
        case FALSE_ GUID_CONSTANT:
    case AND_  GUI  D_CONSTANT:
                      case OR_GUID_CON    STANT:
    case XOR_GUID_CONS   T          ANT:
        case     NOT_GUID_    CONSTANT:      
    c     ase     E   QUIV_GUID_CONSTAN  T:
    cas  e IMPLI           ES_G        UID_CONST   ANT:
    case F ORALL  _GU ID_CONSTANT:
              ca                  se      T   HEREEXISTS_GUID_     CONSTANT:
             case    THEREEXISTEXACTLY_GUID_CONSTANT:
    case   T HER     EEXISTATMOST_GUID_CONSTANT:
        case THEREEXI     STATLEAST_G        U ID_CONSTANT:
    case        E XPAN  DSUBLF      N_GUID_CON       ST  ANT: 
    cas  e SUBLQUOTEF   N_GUID_CONST   ANT:
         va    l =   co reCon   stant(false);
      brea  k;
       case CONSTANT  _NAME1:       
      t =  j j_co nsume_to      ken(CONSTANT_N   AME1);
                                va   l = m      akeCon          s t  antFr omName(t.image     );
      b  reak;
    cas              e      C  ONSTANT_N        AME      2:
         t = jj_consume_t    oken(C     ONSTANT_NAME2);
                                       val = makeConstant FromN    ame  (t.i    mage);
            b    rea  k;
     ca   se     CONSTA NT_GUID:
      t   = jj_consume_token(CONSTANT_GUID);
                                    va           l   = ma    keConsta    ntFromGUID(t.image.substring(2));
       break;
      case CONSTANT_GU    ID2:
        t    = jj_consum     e_toke         n(CONSTA  NT_G     UID2)             ;                
                                              val =        m   akeConsta   ntFromGUID(t.ima ge.substring(3,          t.image.length(  ) - 1));
        brea     k;
       default:
                jj_la1[   2       5] =     jj      _gen    ;
      jj_c   onsume_to   ken(-1);
      t      hrow n  ew ParseExcept   io  n()   ;
             }
    eof(requi   reEOF);
    { if (true) ret     urn     val     ;    }
           throw     new Er          ror("Missing ret  urn stat   ement in f   un   ction")    ;
  }    
       
  fina l public Cy cCo   nstant makeConstan   tFromName(Stri   ng name) throws ParseExcept    ion {
  Cyc   Co      nsta  nt v   a  l  = null;
    if (nam  e.sta   rtsWith  ("#$")   ) {
              name = name.subs    tring(2);  
    }
    val = CycObjectFacto ry.getCy  cConst    antCache  ByN    ame(      n         ame);
    if     (val ==    null) {
         tr    y {
                 v   a  l = new CycC    onstant(name, null);
         } catch            (Exce           pti  on e) {
        {if (    true) throw new        Pars  eException(    e.g      etMessage());}
      }
          }
    {if (true) return val;}   
       t   hrow new Er   ror      ("Missing return statem ent   in function");
  }

           final      public CycC    onstant  make  C  onstantFrom GUID(String guidS  tr) throws ParseExcep   tio        n {
  CycConstant val = null;
  Gui  d guid   = null;
    guid =    CycObjectFactory.makeGuid(guid    Str);
    val = CycOb  jectFactory.ge    tCycCon   stan     t         Cac    heB      y     Guid(gui           d);
    i       f (val == null) {  
           t      ry {
        v  a l = new CycC onstant(null, guid  );
      } cat      ch (Exception    e) {
                    {if (true) thr             ow new P      a   rseEx    cept   ion(e.get                     Me   ssage());}
      }
        }
    {if (true  ) ret    u    rn val;}
    throw new E     rror("      Missing return statement in f  u  nction");
   }
    
               f     inal    public    CycConstant coreCo        nstant(boolean requireEO   F) throws       ParseE  xcep     tion, java.io .  I     OExc eption, Un suppo        rtedVocabularyExcepti        on {
  Cyc   Consta  n   t va              l = n     ull;
            switch ((jj  _ntk= =-1)?jj_    nt    k( ):jj_   ntk) {
    case TR      UE_GUI      D_CONSTANT:
    case FALS   E_    GUID_CONSTANT:
           c                ase AND_GUID_CON  S    TANT:
    case  OR_GU   ID_CONSTANT:
    c ase XOR_G    U          ID     _C    ONST    AN      T:
    case N      OT     _GUID_CO    NSTA    NT               :
              case EQUIV _G       UID_CONSTAN     T:
    case IMPLIES_GUID_C  ONSTAN     T    :
    case FORALL_GUID_C ONSTANT:
    case THEREEXISTS_GUID_C   ONS T    ANT:
    case THEREEXISTEXACTLY_GUID_CONSTANT:
    case TH EREEXISTATMOST_GUI   D_CONS   TANT:
      case THER     E    EXISTA           TLEAST_GUID_CONSTANT   :
     cas   e EXPA NDSUBLFN_          G         UID_C      ONSTAN     T     :
    case SUBLQU   O TEFN_GUID_CONST ANT:
         val    = coreGUIDC  onstant(fal            se);
      break;
    case TRUE_      CON  S                   TANT:
    case               FALSE_    CONSTAN     T:
      c    ase     AND_    CO  NSTANT:
    c   ase   OR_CO   NSTANT:
    case XOR_CONSTANT:
    c ase NOT_CONSTANT:        
    case EQ  UIV_CONSTANT:   
        case IMPLIES_CONSTANT:
        cas    e FORALL_CONSTA  NT:
       cas      e THEREEXISTS_CONSTA   NT: 
    case       THER    EE X      IS  TEXACT    LY_C ONSTANT:
         case THERE    EXISTAT   MOS    T_CONST  ANT  :
    case T HE                 REEXISTATLEAST_CO  NSTANT:
    c    a   se EXPANDSUBLF     N_CONSTANT:
          case SUBLQUOTEFN_CONSTANT:
          val       = coreNameCons      tant(false);         
      break;
    default:
           jj_la1[26] = jj_gen;
      jj_consume_tok     en(-1);
           throw         new    Par   s   eException();
    }
    e   o      f(req  ui   reEOF);
    {if (true) re turn     val      ;}
     throw new Er  ror("Mis  sing return st     at    ement in function");
  }

       f   inal      pu           blic CycConstant core    NameCo    nstant(boolean requireEOF             ) throws ParseException, java              .io.IOException, Unsuppo  rtedVocabularyE     x    ception {
  Cy   cConstant va  l = nu  ll;
    switc   h (   (jj_ntk  ==-1)?jj_        ntk():jj_ntk) {
       cas      e TRUE   _CONSTANT  :
      j      j_consume               _token(   TRUE_CONSTANT);
                                 val = Cy  cAcc    ess.tru   eConst     ;
      b    reak;
           case F        ALSE_CO NS    T      ANT:
            j     j_consum e_toke      n(FA    LSE_CO     NSTANT);
                                          val    =                CycAcc    ess.falseConst;
      bre     ak;
         c ase AN   D_CON   STA        NT:
      jj_c  onsu    me_token(AND_CONSTANT);  
                         val = CycAcce     ss.     an    d;
          break   ;
    c   ase OR           _CONST  ANT:
      jj_consume_token(         OR_CONSTANT);
                                                  val = CycAcce s    s.or ;
          break;
        case XOR_CONS TANT:
      jj_consume_t    oken(XOR_CONSTANT);   
                           val = CycAcce   ss.xor  Co      nst;
          break;
         case NOT_CONSTANT:
          jj_consume_to      ken(NOT_C   ONSTA  NT    );
                                val = CycAccess.not;
      break;
    cas   e      E   Q   UIV_CONSTANT:
           jj      _c  on        sume_token    (E  QUIV   _CONSTANT);
                                 val = CycAccess.equivCon         st;
      break;
    cas e IMPLIES_CONSTANT:
      jj_   consum  e_t  oken(I MPLIES_  CONSTA   NT);     
                                                  val = CycAccess.impl     iesConst;
       break;
         cas     e FORAL  L_CO   NSTANT:
        jj_    consu  me_tok   e      n(    FORALL   _CO       NSTANT);
                                           val = CycAccess.forAllConst;
      break;  
    ca  se THEREEXI    STS_CONSTANT:
      jj_consume_t    ok   en(THE REEXISTS_CO N  ST   ANT     );
                                                   val = CycAccess.thereExistsConst   ;
      b r    eak;
     case T      HEREEXISTEXAC    TL Y_C     ON   STANT:
            j   j_consume_t      oken(THEREEXIS   TEX  A  CTLY_CONSTA  NT)          ;
                                             val = CycAccess.thereExis   tExactlyConst;
         break;
    case    THERE     EXISTATMO  ST_    CONST   ANT:
      jj_con    sume_token(THEREE    XIST               AT MOST_CONS   TAN      T);
                                           val = CycAccess.thereExistAtMostConst;
      b           reak;
    case THEREEXISTATLEAST_CONSTANT:
        jj_consume_token(THEREEXI  STATLEAS   T_CONS  TANT) ;
                                                        va l = CycA cce   ss.thereExis  tAtLea      st   Co   nst;
       bre    ak;
        case EXPANDSU BL  FN_CONSTANT:
               jj_consume_    token(EXPANDSUBLF          N_C ONSTANT);   
                                    {if (  true) throw ne     w Unsup portedVocabula    ryEx  ception(CycAccess.expandSubL   F     nConst);}
      break       ;
            case SUBLQU   OTEFN_      C  ONSTANT:
              jj_co  nsume_token(SUBLQUOTEFN_CONST ANT);
                                                               {if (true) throw n   ew   Unsupported   VocabularyException(Cyc     Access.     s    ublQu  oteFnConst);}
          break;
          defaul       t:
        jj_la 1[27] = jj_ge     n;
             jj_c   onsum     e_toke   n(-1); 
      t  hrow new      ParseE    xception() ;
    }
    eof(requi reEOF);
    {if (true) return va     l  ;}
    throw new E    rror("Missing return statement in func  tion");
  } 

  final public CycCons   tant co  reGUIDConstant        (boo  lean requir    eEOF) throws       ParseException, java.io.IOE  xcepti   on,      U         nsup port    edVocabularyE  xc         eption {   
  CycCons         tant val    = null;
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TRUE_GUID_CONSTANT:
        jj_consu me_token(TRUE_GUID_CONSTANT);
                                          val = CycAcces    s.trueConst;
      break;
         case      FALSE_GUID_CONSTANT    :
      jj_consume_token   (FALSE_GUID_CONSTA   NT);
                                                   val = C   ycAccess .falseCon     st;
      break;
        case   AND_GU  ID_CONSTANT:
        jj_    consume       _toke  n(AND_GUID_ CO      N      STANT);
                                                v    al       = CycAccess  .and;
      break;
        c     ase OR_GUID  _CONSTANT:
          j j   _cons um    e_token(OR_GUID_CON    S       TA   NT);
                                   val = CycAccess.or  ;
          break;
          case        X       OR_GUID_CONS     TANT  :
      jj_c onsum     e_tok  en(    XOR_GUID_CO   NSTANT); 
                                     val = CycAccess.xorConst;  
        brea      k    ;
    case    NOT_GUID_CONSTANT:
        jj_consume_token(NOT_GUID_CONSTANT     );
                                        va   l = CycAccess.not;
      break;
    case EQU   I  V    _GUID  _CONST A  NT:
      jj_consume_token(EQUIV_GUID_CONSTANT    );
                                         val = CycAccess.equ        i  vC    ons   t;
      break;
      case I     MPLIES_G   UI    D_CONSTANT:
      jj_  consume_token(  IMPLIES_GUID_CON    ST   ANT);
                                      val = CycAccess.i   mpliesCon  st;  
      break;
    case       FO RALL_GUID_CONSTA     NT:
      jj_consume_t   oken(FORALL_GUID_CONSTANT          );
                                          val =      CycAcce    s    s.forAllCo   nst;
      brea k;
         c   as      e THE   REEXISTS_GUI    D_C        ONSTA    NT  :
         jj_consume_tok    en(T   HEREEXIS    TS_GUID       _CONSTANT);
                                                 val    = C           ycAccess.th   ereExistsConst;
       break      ;
     ca   se THEREEXISTEXACTLY_GUID_CONS     TANT:       
      jj_co    ns  ume_token(THEREEXISTEXACTL Y_  GUID_C     ON   ST     ANT  );
                                                             val = CycAccess.thereExistExactlyCons   t;
      break;
                 case THERE    EXISTATMOST_GUI           D_CONSTANT:
        jj_con     s    um    e_token(THEREEXISTA  TMOST_G    UID_CONSTAN        T);
                                               val = CycAcc   e ss.thereExistAtMostCon              st;
      break;
             c ase THEREEXISTATLEAST_GUID_CONSTA                NT:
      jj_c         onsume_token(THEREEXISTATLEAST_GUID_   CONSTANT);
                                                                          val = CycAcc       es  s  .thereExistAtLea    stConst;
               brea           k;
                ca    se EXP   ANDSUBL   FN_GUID_CON    STANT: 
      jj_c onsume_to    k    en(EXPANDSUBLFN_GUID_CONST      ANT);
                                       {if (true) throw new UnsupportedVocabulary   Exception    (Cy    cAcce      ss.expandSubLFnConst);}
          brea        k;
    ca    se SUBLQ     UOTEFN_GUID_CONS                  TANT:
      jj_consume_to    ken(SUBLQUOTEFN_GUID_CONSTANT);
                                                 {if (true) throw ne  w UnsupportedVocabularyExc     eption(CycAccess.expand   Su bLFnConst);   }
      break;
    defaul  t:
             jj_la1[    2   8]  = jj_gen;
           jj_consume_token(-1) ;
      throw ne   w ParseException();
    }
    e  of(r        equireEOF);  
    {if (         true) ret    urn    val;}
    thr   ow      new         Error("M  issing      return statement in f   unction      ");
  }

  final    pu        blic CycVariable sen   tenc      e       DenotingVariable(boolean requireE   OF) throws    ParseException {
  Cyc    Vari  a    b   le val    = null;
    switch ((jj_ntk==-1)?jj_ntk():jj  _ntk) {
    case SIMPLE_VARIABLE:
      val = sentenceDenotingSimpleVariable         (false);
      break;
    case META_VARIABLE:
      va    l         =    se     ntenceDenotingM    etaVariable(false);
         break;
    defau      lt   :
         jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw     new ParseExcept  ion();
    }
    eof(requireEOF);
    {if (true) return val;    }
    throw    new Error   ("Mi     ssi   ng return stat ement in fun   ction");
  }

  fin        al public CycVariable var      iable(boolean require      EO     F) throws ParseExcept  ion {
  CycVar  iabl    e val = null;
    swit  ch     ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIMPLE_V      ARIABLE:
      val = simpleVariable(false);
      break;
    case META_V  ARIABLE:
           val = metaV  a    r   ia       ble(false);
         break;
    default:
      jj_la1[30] = jj_ gen;   
      jj_consume_token(-1);
      throw new P   ars eException();
    }
    eof(requireEOF);
    {if (t   rue) return val;}
          throw new Error("Missing return       statement in function");
  }

  final public CycV  ariable sentenceDenotingMetaVariable(boo       lean requireEOF) thr     ows P    ars      eException {
      CycV ariable val = null;
    val       = metaVariable(f      alse) ;
    eof( requireEOF);
    {i     f (t   rue)          return v    al;}
    throw new Error("Missing return      st   atement in function"    );
  }

  final pub  l   ic    Cyc Variable sen tenceDenotingSimpleVariable(b         oolean require  EOF    ) thro ws ParseException {
  CycVariable val =  null;
    val = simpleVariable(f      alse); 
    eof(requ     ireEOF);
    {if (true) return   val;}
        throw new Error("Missing return statement      in function");
  }

     fina   l publ ic CycVariable m      etaVariable(  boolean requ  ireEOF) throws ParseException  {
  Cy  cVariable    val = n ull;
  Token t =         nu  ll;
    t =           jj_cons    ume_     token(META_VARIABLE);
                                          val = new  CycVariab   le(t.image);
    eof(r  equireEOF)      ;
    {if           (true) retu    rn val;}
    thro     w new Erro         r("Mis      sing return statemen      t in function");
  }

  final public CycVariable simpleVariabl  e(boolean re  qu ireEO  F)     throws ParseExcept i  on {
  Cy    cVariable val = null;
  Toke   n t         = null;
                t = jj_consume_token(SIMPLE_VARI      ABLE);
                              v   al = new Cyc    Variabl  e(t    .im   age);
    eof(requireEOF);
    {if (true) ret     urn       val;}
    throw new Error("Missing return statement in func     tion"    );
  }

  final public String string(b   oolean requireEOF) throws ParseE    xception {
  Toke   n t = null;
    t    =     jj_consume_    toke  n(STRI         N   G);
        eof(    requireEO F);
    {if (true) return t.im   age.substring    (1, t.im   age.length()-1);}
    throw new E  rror("Missin  g return statement in function");
  }

  final public   N umber    number(b    oolean requireEOF) throws ParseException {
  Num    ber val = null;
    Toke    n t =    null;
    switch (     ( jj_ntk==-1  )?jj_ntk():jj_ntk) {
    case INTEGER:
         t = j     j_consume_token(IN   TEGER);    
                             val = new Long((t.image.startsWith("+" )) ? t.image.substri  ng(1) :    t.im age);
      break;
            case FLOAT:
            t     = jj_consume_token(FLOAT);
                                 val = new D   o   uble(t.image.toLow erCase().replaceAll("d", "e"    ));
      break;
    defau   lt:
      jj_la1[31]        = j       j_gen;
      jj_consume_token   (-1);
      throw new ParseException();
        }
       eof(requir       eEOF);
    {if (true)   return val;}
    th    row new Error("Missing return statement in f   unction" ) ;
  }

  private bo   olean jj_ 2_1(int xla)    {
    jj  _la        = x       la; jj_la         stpos    = jj_scanpos = token;    
    t   ry { return !jj_     3_1(); }
     catch       (Looka hea  d   Success ls) { re    turn true; }
        finally {        jj_save(0, xla); }
  }

  private boolean jj_3_1() {
    Tok  en xsp;
    xsp = jj        _scanpos;
    if (      jj_scan_token(15)) {
          jj_scanpos = xsp;
    if (jj_sca   n_token(30)) {
    jj_scanpos = xsp;
       if (jj_scan_to       ken(16)) {
    jj_scanpos = xsp;
        if (jj_s      can_toke  n(31)) {
    jj_scanpos = xsp;
    if (jj_s      can_token(73)) {
    jj_scanpos = xsp;
       if (jj_scan_token(75)) {
    jj_scanpos     = xsp;
    if (jj_scan_token(1)) return true;
    }   
    }
    }
       }
     }
    }
    return f   al se;
     }  

  /** Generated Token Manager. */
  public CycLParserTokenManager token_source      ;
  SimpleCharStream jj_input_stream;
  /** Current t ok    en. */
  public Token token;
  /** Ne  xt     token. */
  public   Token    jj   _nt;
  private int jj_ntk;
  private Tok      en jj_scanpos, jj_l       astpos;
  private int jj_la;
  p  rivate    int jj_gen;
  final private int    [] jj_la1 = new in     t[32];
  st   at  ic private int[] jj_la1_0;
  static private int[] j     j_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
        jj_la1_init_1();    
       jj_la1_init_2();
   }
        private st  atic void jj_la1_init_0() {
         jj_la1_0 = new int[] {0xffff8002,0xffff8000,0xffff8002,0xffff8002,0 x100000,0x 20000,0x40000,0x80000,0x400000,0x200 000,0x800000,0x1000000,0x2000000,0x400  0000,0x8000000,0xffff 8       0     02,0x0,0xffff8002,0x0,0xffff8002,0xffff8002,0xffff8000    ,0xffff8000,0xffff8000,0x0,       0xffff8000,0xffff8000,0x3fff8000,0xc0000000,0x0,0x0,0x0,};
   }
   private static vo    id jj_l   a 1_init_1(      ) {
        jj_la1_1 = new int[]    {0x          30001fff,0x30001fff,0x1  fff ,0x1fff,0x8,0x1    ,0x2,0x4,0x20,0x10,0x40,0x80,      0x10     0,0x2  00,0x 400,0x1fff,0x0,0x30001fff,0x0,0    x1fff,0x30001fff,  0x30001fff,0x1fff,0x1fff,0x30000000,0   x1fff,0x1fff,0x0,0x1        fff,0x0,0x0,0x300     00000,};
   }
   private static vo       id    jj_la1_init_2() {
      jj_la1_2 = new int[] {0x2b62     ,0x2b62,0xb62,0xb62,0x0,0x0,0x0,0x0,0x0,0x 0,0x0,0x0,0x0,0x0,0x0,0        xb62      ,0x4000,0x2b62,0x4000,0xb62   ,0x2b62,0x2b62,   0xb62,0xb62,0x2000,0x16    2,0x0,0x0,0x0,0xa00,0xa00,0x0,};
   }  
  final private JJCalls   [] jj_             2_rtns = new JJCalls[1];
  private b  oolean jj_rescan =     false;
  private int jj_gc = 0;

  /** Co   nstructor with InputStream. *  /
  public CycLP          arser(java.io.InputStrea m stream)  {
      this(stream, null);
  }
  /** Constru   ctor with InputStream and sup   plied encoding */
  public    CycLParser(java.   io.Inp   utStream stream, String encoding) {
            try { jj_input_stream = new SimpleCharStream(stream, encoding, 1       , 1); } ca  tch(java   .io.UnsupportedEncodingException e) { throw new RuntimeExc   ept   ion(   e); }
    token_   source = new CycLParserTokenManager(j     j_input_s    tream);
    to ke n    = new Token(  );
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1 [i] = -1;
    for (int i      = 0; i <        jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
      public void ReIn  it(java.io.InputStream stream) {
     ReInit(stream,    nu    ll);
  }   
  /** Reinitialis e. */
  public void ReInit(java.io        .InputS  tream stre  am, String      encod ing) {
    try { jj_input_stream.ReInit(  stream, encoding, 1,     1); } ca      tch(java.   io.UnsupportedEncodingException e) {      throw new    RuntimeExce      ption   (e); }
    t     oken_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk        = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) j    j_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i      ++) jj_2_rtns[i] = new JJ       C   alls();
  }

  /** Constructor. */
  public CycLParser(j  ava.io.Reader stream) {
    jj_input_strea  m = new Simple      CharStream(stream, 1, 1);
    token_source = ne         w CycLParserTok    enManager(jj_in   put_stream);
    token =     ne    w Token();
      jj_ntk = -1;
    jj_gen  = 0;
    for (int i = 0; i    < 32; i++)   jj_la1[i]      = -1;       
    for (int i = 0; i < jj_  2_rtns.length; i++) jj_2_      rtns[i] = new JJCalls();
  }

        /** Reinitialise. */
  public void ReInit(jav   a.io.Reader stream) {
      jj_input_stream.ReInit(s   tream, 1, 1);
    token_sou  rce.ReInit(jj_input_stream);
     token = new     T   oken();     
    jj_ntk = -1;
    jj_gen = 0;
    f  or (int i = 0; i <    32; i++) jj_la1[i] = -1;
    for  (int i = 0; i < jj_2_rtn    s.length; i++) jj    _2_rtns[i]    = new JJCalls();  
  }

     /**   Constructor with generated Token Manager. */
  public    C         ycLPa   rser(CycLParserTokenManager tm) {
    token_source =    tm;      
     token = new Token();
    jj_ntk = -1;
    jj_gen =    0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
         for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = n       e       w JJCalls();
  }

  /** Reini      tialise. */
  public voi     d Re      Init(CycLPar    serToke nManager tm) {
    token_source = tm;
    token = new Token();
    jj_nt     k = -1;
    jj_gen = 0;
    for (int       i = 0; i < 32    ;     i++) jj_l  a1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] =    new JJCalls();
  }

  private Tok        en jj_co   nsume  _token(in   t kind)   t hrows ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
            else token    = token.next = token_sour   ce.getNextToken();
    j  j_n  tk = -1     ;
    i     f (token.kind == kind) {
      j    j_gen++;
        if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj _2_rtns[i];
               while (c != null)      {      
            if (c.gen < jj_gen) c.first = null;
               c = c.next;
            }
           }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_t       oken(int kind) {
    if (jj      _scanpos == jj_lastpos) {
      jj_la--   ;
        if (jj_s canpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNe     xtToken();
      } else {
        jj_lastpos =      jj_scanpos = jj_scanpos.next;
      }
    } else {
      j  j_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i =      0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; to      k = tok.next; }
      if (tok != null) jj_add_error_to   ken(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return    false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.n        ext  ;
    else token = token.next = token_source.getNextToken();
      jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final          public Token     getToken(int index) {
    Token t = token;
    for (int i = 0; i < in    dex; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }
     
  private     int jj_ntk() {
    i   f ((jj_nt=token.next) == null)
      return (jj_ntk =     (token.next=token_source.getNextToken   ()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  privat    e java       .util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>(    );
  private int[] jj_ex  pentry;
  pri         vate int jj_kind = -1;
  private int[] jj_lasttokens = ne w int[100];
  private int jj_endpos;

  private vo  id jj_add_error_token(int kind, int pos) {
    i f (pos >= 100) ret  ur n;
    if (pos == jj_endpos + 1) {
      jj_    lasttok   ens[jj_   endpos+    +] = kind;  
    } else if   (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens   [i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentri    es.iterator(); it.hasNext();) {
                int[] o   ldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.leng  th; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);   
          break      jj_entries_loop;
        }
      }
      if (pos != 0) jj_lastto kens[(jj_endpos = pos)     - 1]         = kind;
    }
  }

  /** Generate Pa  rseException. */
  public ParseException generateParseException() {
    j         j_expentries.clear();
    boolean[] la1tokens = new boolean[79];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 32; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
             if ((jj_la1_1[i] & (1<<j)) !=     0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
               la1tokens[64+j]       = tru   e;
            }
        }
      }
    }
    for (int i = 0; i < 79; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[ 0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new in   t[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i+     +) {
      exp   tokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

      /** Disable tracing.  */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p =      p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = x  la;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

  }
