/*    DBInterpreter.java */
/* Generated By:Java   CC: Do not e     dit this line. DBInterpreter.    java */
      package edu.purdue.     cs448.DBMS     ;


    import edu.purdue.cs448.DBMS.     Structure.     *;
    import j     ava.util.*;
    import     java.io.InputStream    ; 
          import java.io.IOException;     
 
    pu            bli     c class DBInt     erpreter        impl ement      s DBI      nterpreterConstants          {
            public static void mai    n(String[ ] args) throws IOE      xception{
                  DBInter            p             reter interp  ret  er;
               DBUse     rControl  l      er use rCon  troller;
                                    DBExe cutor exe  cu    tor;
                   Que    ry quer  y;
                                       InputStre      am input      ;

                          if             (args     .len gth != 1) {
                                            Syst   em.ou    t .pri  ntln("Use:    min  idbms   <        us    er  N  ame>  ")         ;
                                 return;
               }
   
                                               String userName =        args[0];

                            userCo      ntrol         ler = ne        w           DB    U  se                r  Contr      olle                r(    userNam           e) ;

                          input  = Sy   s  tem.  in;
                                                              i                nterpret     er = n                        e       w D             BInt erpr           eter(in             put);


                                                 exec  ut  o r = new      D   BExec    utor  (     );     
                                     w               h       ile  (t      ru    e){
                                               tr          y    {
                                                                                    /   /       Pr          ompt when      in interac    tive       m ode
                                                                      i          f(input        ==                                 System.in){
                                                                                                                                         Syst    em.out.pri nt("YSQL>>")      ;
                                                   }    
                                                         q             ue  ry           = i   nterpr  eter.Qu    e    r  y(  );     

                                                                               qu ery =  u   serC      o         ntro       ller. us     e        rCheck(que        r y  ) ; 

                                                                              if(query !=      nu      ll){
                                                                                      executo  r.execu        te(q        u  ery);
                                                         }

                                                                                  if(inpu          t !=         Syste                    m.in       &&        i   nput.avail able() == 0    ){ 
                                                                                       ret   urn;
                                                                     } 
                                                            }   ca tc h  (P       arseE   xc       ep           tio     n e  x) {
                                                                                                                                       System.    e   rr   .println(ex. ge  t        M    essage());
                                                                                                                                    return;
                                                    } c   atc   h      (Er  ror e       x   ){
                                                    System.err.println(ex.ge       tMessag  e()   );    
                                                       return;
                                              } c       a     tc  h       (I            OE        xcepti on      ex){
                                                System.err.prin  tln("  Y       SQL: IO       Exception");  
                                                                     r      etur n;
                           }
                       } 

   
              }
                                             //a method to    recov   er from syn       ta    x    er    r      or
                          void  error       _skipto(i   nt ki   nd) {

                             Toke  n      t;   
                                      do { 
                                                        t = getN   extT  oken();
                                             }  while ( t.kind       !=    kind);
                                                                            /  /   The above lo   op cons  umes tokens al  l t     he w     ay up t           o a token of
                                              // "kind".              We use a d  o-while lo   op rather t     han a while because th     e
                                                             // cur  rent tok   en is    the one     imm      ediately  before    the e     r ro     n    e   ous token
                                // (i  n   our c     a s     e the tok en immediately           be fore what   sho         uld  ha                     ve been    
                                                               // "if"/"while".
                              }   
    
// Gr                  ammar
      f    inal public Query  Query() t    hro  ws ParseEx     ception {Query que ry = nu  ll;
        try {
      sw       itch ((  jj       _ntk==-1)    ?j j_ntk_f()   :jj_ntk) {
       case 0:{
                      jj_consume_token(0)    ;
{if ("" !=   nu    l      l) return null;  }
         bre    ak;
            }
               case   KWO   RD_SELECT  :
              case  KWORD_I   N SE   R       T:
                      case KWORD    _UPDATE:
         case KWORD  _  C   REATE             :
          case K          WORD_DELETE:
                      case KWORD_DROP:
       ca   se KWORD_H   ELP:
           case KWO     RD_      QUIT                   :{
           query =       S      QLStatement()     ;
          jj_consume_to    ken(SYM_SEMICOL  O   N);
{if (""     != null) ret       urn qu   ery;  }
        break;       
                 }
        default:
         jj_la1[0] = jj_gen;
                        jj_con    sume_token(-1);
                  throw new   P  ars    eException();
       }
      } c     at  ch      (Par   seEx  ception    e) {
 Sys  tem.out.print  ln(e.toString());
                     erro   r_skipto(SY   M_S     EMIC     OLON);
                                       {if ("" != nu         ll) return null;}
           }
       throw new Error("Mi      ssi   ng     return statement      in f         u        nction"   )    ;
  }     

//       FI    LLIN: Remai nder     of     t      he grammar   
   fi    nal     publ ic    Qu    ery SQLStatement() throws Par  seExceptio   n {Qu   ery query;
         i      f (jj_2_1(2  )) {
        jj_  consume_token(KWORD_CREATE)    ;
               jj_ consume            _token( KW ORD_T     ABLE);
      query =  Create();
    } else {
      switch ((jj_ntk==-1)?j       j_nt  k_f():jj_ntk  )  {
      case KWORD_DROP:{
              jj_consum e_to        ken   (           KWORD_DROP);
                jj_consum  e_token     (KWORD  _TABLE)  ;
        q     uery =               D  r  op      ();
                         break;    
            }
      case KWOR       D_SELECT    :{ 
                      j      j_ co   nsu                me_token(K    W     O   RD_SELECT);
          que       ry = S  elect( );
              break;
                      }
       c       ase      KW   ORD_INSERT:{
           jj_consume_token(KWORD_INS ERT);     
         jj_c    onsu  me_token      (KW   ORD_INTO);
                   que ry    =  I  nse       r  t();
        br   eak;
                     }
                  de    fau    lt    :
                     jj_la1[1] = jj_gen;
             if  (jj_2 _2(2))    {
                  jj_c          ons  ume_   token(KWORD_       DELET   E)   ;
               jj_co       nsu   me_token     (KWO         RD_FROM); 
                   query =              De   lete();
           }     else {
                  sw  itch   (    (jj_ntk==-1)?  jj_   ntk_f():jj       _ntk)        {
             c     ase    KW   OR        D_UPDATE:{    
              j  j   _cons  um                e_  token(      KWOR                    D      _UP  DATE);
              query = Up   date   ();         
              break;
                       }
            case KWORD_H           ELP:{
                   jj_co         nsume_t oke        n(KWORD_HELP);
                                     query = Help( );
                     br      e          ak;
            }
                       case KWORD_QUIT:{
            jj_consu       me_toke   n      (KWORD_QUIT);
            query = Quit();
            break;
                  }
                   d    efault:
               j             j_la1[2] = jj_gen;   
                if (jj_2_3(2)) {
                               jj_co         nsume_token(K   WORD_CREATE);
                      j  j_co       nsum e_t ok   en(K  WORD_USE   R);
                     query =  Creat     eUse  r();
                    } else {     
                       switc  h  (   ( jj_ntk==-1)?     jj_   ntk_f():jj_ntk    ) {
              c               as      e KWORD_DELETE:      {
                   jj_consume_token(KWOR D_DELETE);
                          jj_cons     ume_     token    (KWORD_USER);
                              query      = Dele t  eUser()        ;
                         b     reak  ;
                    }
                                           cas   e   KW   OR                D_CREATE:{   
                  jj_co      nsume_to     ken  (KWORD_ CREA   TE);
                jj_con     sume_token(KWORD_SU       BS CHEMA);
                          que  ry = CreateSubschema();   
                br     eak; 
                }
              defaul  t:
                            jj_l   a1[3]   = jj     _gen;
                           jj_c  onsume_token(-1);
                throw ne   w Pa r seExcepti   on( );
                             }
                          }
             }
        }
      }    
       }
{if        (   "" != nu  ll)    retur   n qu     ery;}
              t  hr   o  w new Er  ror("Missing return statement in functi     on");
     }

        final public Create  S       u bschema C  re   a    te   Su   bschema()      throws Pars  eExcep  tion   {Q  uery query;
                Toke       n tableName;
              Token attrName;
          ArrayList<String> attrNameL    ist  = n   e     w ArrayList<String>();
     tableName       = Id     ent     ifier();
    attr   Name = Id     entifier();
a   ttrNameList.add(attrName.im     age);
    label_1:
    while (t             ru     e)      {
      switch (   (jj_nt   k==-1)?  jj_ ntk_f():jj_ntk)     {    
      case SYM_COMMA:{
            ;
            break ;
            }
                     default:
                     jj_la1[4] = jj_gen;
               break lab    el_1;
         }
      jj_con      sume_ token(      SYM_COMMA);
        a ttrN a      m e = Identif    ier()  ;
att    rNameList.add(attrNam              e.i     ma  ge);
    }
{if (""  != null)  return new Create     Su  bs   chema(tableN ame .    image,    attrNa   meList);}
         throw new E    rr   o       r("Mis  sin   g r     eturn statement in function");
    }

  final public CreateUs er C   reate     User() throws ParseExcep tio n {  Qu    ery que ry;
     Token userName;
        Use              r.UserType userType;
    userName = Identifi      er();
    switch  ((jj_ntk                 ==-1              )?jj_nt            k   _f():jj_ntk) {
          cas e      56:{     
            jj_consume_token(56);   
user T    ype = User   .UserType.US       ER_A;     
      break;
      }
    case 57  :{
      jj_consume_token(         57)             ;
userType   =       User.User  Type.US     ER_B;     
                 break;
            }
      de    fault:
        j     j_la1[5] = j     j  _gen;
             jj_cons     ume_token(-1); 
      throw new   ParseE    xception();
      }
{if ("    " != null)    return n          ew CreateUser(u    serT  ype, userNa   me.image);}
         th        row new Err          or("Missing return sta    tement in   functi   on");
  }
            
  final public Delet         eUs    er Del    eteU        ser() throws    P  a                rseException {Query que        ry;
    Token      u   serName;
              userNam   e = Ide ntifier();
{     if    ("" != null      )      retu  rn ne  w DeleteUser(us     er        Name.image)   ;  }
    throw new                 Error       ("Mi        ssing r  etu     rn statement                     in fu  nction");     
  }     

  final pub   lic   C   reate Crea       te() throws ParseException {Toke  n tableName;
          Token attrNa     me      ;
        Ar   rayList<Attribute> attrLi   st        = new     ArrayList<Attri    bute>();
       H    a sht     able<Strin   g, Integer> attrPo  sTable = new Hashtable<String, I      nteger       >();
    Attribu      t  e                a    ttribute      ;    
    Tok  en lengthToken = null;
    Conditio n  cond = null;
    Attribute.Typ   e type;
    ArrayList<Integer> p rimaryList = new   Arr    ayList<   Integer>();
    Token forei   gnTableName;
     Token  fo  reignAttr ibute   ;
     Hashtable<Strin       g, ForeignReferences     >    foreig     nRefTab      le     = ne  w Hashtable<S  tring, F   ore  ignR                               efe  re  nces>               (   );
    tableNa     me = I dentifier();
       jj_c             onsume_token(    S            YM_L     PARENTHESE); 
    label_2:
    while   (tr      ue) {
          a ttrNa        me    =                Identifier();
            switch ((jj_            ntk==-1)?jj_ntk_f  ():jj_  n  tk    )     {
      case KWORD_      DEC    IMAL:{
                       jj_consum            e   _token(KWOR    D_D ECIMAL);
type = Att    rib  ute.Type.DECIMAL;   
         break;
        }
            case      KWORD_INT:{
           jj_c     onsume_token(KWORD_I   NT);
type = Attribute.T ype.IN   T;
             break     ;
        }
            c     ase       KW           ORD_CHAR:{
        jj_cons   ume      _token(KWORD_CHAR);
ty  pe  = At  tribute .Type.CHAR;
         jj_c      onsu  me_token(SYM_LPARENTHESE);
            leng   thToken =      jj_c     onsume_token(I   NT_LITERAL);
                 j    j _consume_token(SYM_RPARENTH      E   SE);
                br         eak;
                 }
      default:
         j      j_l  a   1[6] = j  j _gen; 
        j     j_consume_ token(-1)  ;
              t hrow new ParseExcep  tion();
      }
      switch    ((jj_ntk==-1)?jj_ntk_f()        :jj_ntk)    {
             c    a   s    e KWO         RD_  C H   ECK:{      
           jj _consume_token   (KW             ORD         _CHECK);
        jj_c         onsume_token(S        YM_L P        ARENTHESE);  
                c    o  nd             = Co  ndition();
        jj_  consume_toke  n(SYM_RPARENTHESE);  
        b     r  eak;
        }
      default:    
         j   j_l  a1[7           ] = jj_gen;
        ;
         }
             jj_co     ns um  e_toke  n(S    YM    _    COMMA);
    if(cond != null && !cond.idCheck     (  attrName.        image))
                            {if (   true) throw new      Error(    "CREATE TABLE: CHECK ATTR  IBUTE INVA    LID " +          attr  Name.  ima           ge);}
                       at        tribute = new    Attribu  te(type ,  at    trName.image);
                           if(lengt    hToken !=                            n  ull     )attribu  te.setLen    gth(Intege          r.parseInt(len   gt      hToken.imag   e));
                          if(co   n            d != null){
                                     att          rib  ute.setCheckCond     (cond)       ;
                                                    cond =    null;
                            }
                                i  f(!attrList.contains        (attribute)){
                          //Save    position    of         attribute name
                                                   attrPosTa        ble. put(attrName.     image,    Integer.valueOf(att  rL            ist.s    ize ()          ));
                        attrLis t.add(attribu    te);
                           }else
                           {if (true)        t      hrow new   Error("CREATE TABLE         : DUP       LICATED ATTRIBUTES")      ;}
      sw     i    tch      (          (jj_ntk==-1)?jj_ntk_    f   ():jj      _ntk) {
               case IDENTIFIE        R:{
           ;
        break;    
            }
         defau lt:
                  jj       _la1[8] = jj_gen;
           break label_2;
         }  
          }
    jj_consume_   token(KWORD_PRIMARY);
        jj_consume_t   o ken(KWORD_K EY);
      j   j   _consume_to  ken(SYM_LPAR  ENT H       ESE);
    at   trN            am   e = Identifier( );
if  ( !     primaryLi     st.contains(   at   trN   ame.image) && a       ttrLi st.contains( n  ew Attribute(    Attrib   ute.Type.INT, attrName.image)   ) )
                                    primaryList.add(attr     P   osTable.get(a    ttr     N      a    me    .image))  ;
                            else
                                  {if (true) throw new Err     or("CREATE    TAB   LE: IN VALID   PRIM   ARY KEY " + att     rName.imag   e);}
       label             _3:
           while (true) {
                switc        h ((jj_ntk     ==-1)?j    j_    ntk_f():jj_   ntk)    {
            case        SYM_COMM    A:{
                       ;
              break;
        }   
      defaul  t:
                      jj_la1[9] = jj_gen    ;
         brea      k   label_3;
      }
      jj_consume_token(SYM_    CO MMA);
        attrName = Identifie   r();
if( !p     rimaryList.co     ntains(attrName.image) &&               attrList.con    tai n                          s    ( new Attr ibu          t    e(Attr  ibu   te. Typ     e.INT, attrName.image) )  )
                                    primaryList.add(attrPosTabl          e.   ge     t(att   rNam e.i      mage))  ;
                                 e     lse
                                      {if (tru              e)    throw    new Er     ro  r("CREATE TA BLE: INVALID PRIMARY KEY "     + att rName.image);}
    }
    jj_consu     me_  token(SYM_RPARENTHESE);
    label_4:
    whi le (true) {
      switch ((jj  _ntk==-1)?jj_ntk_f():jj   _ntk       ) {
      case SY  M_COMMA:{
           ;
                    break;
        }
         d    efault:
          jj_la1[10] = jj_gen;
        break la   be    l_4      ;
          }
                jj_   consum        e_t  oken(SYM_      COMMA);
          jj    _consume_token (KWORD_FORE   IGN    );
          jj       _cons  ume_token(K   WORD_KEY);
          jj_   consume_token(SYM_LPARENTHESE);
         attrName =   Identifier();
      jj_co   nsume_token(SYM    _RPARENTHESE);
      jj_consume_token(KWORD_REF);
         foreignTa    bleName = Id  ent  ifier( );       
      jj_consume_token(SY  M_LPARENTHESE);
                fo    reignAttribute = Iden     ti  fier();
        jj_con  sume   _         token(SYM_RPARENTHESE);
if(  !attr     Li   s   t.     contains(n  ew Attribut    e(Attribu te.Type.INT, attrName .    image)))
                                                              {if (true) th  row n       ew Error    ("CR       EATE TABLE: FOREIGN    KEY " + attrName.im  age       + " N   OT EX   I    STS   "   )    ;}  

                                if(foreignTableName.image     .equals(tableName  .i mage))
                                                                           {if (true) th  row   n         ew     Err or("CREATE TABLE: FOREI     GN KEY TAB   LE CAN        NOT      BE THE SAME NAME"); }

                                               foreignRefTabl e.put(attrNam      e.im   age,   new ForeignRefer  enc   e  s(for       eig    nTable     Na   me.image, foreignAttribute.image));
    }    
          jj_    consume_token(S YM   _RPARENTHESE);        
{if (""        != nu   ll) return new C reate(tableName.image,  at   trList, primary Lis  t, forei     gnRefTable, at  trPosTable);   }
       throw new Err   or("Missi  ng return st          at        ement in function");
     }

  f  inal publi   c       Drop Drop()  t     hro          ws ParseExc ep   tion {Dro     p d r  opQuery;
              T  oken table Na   me;
    tabl   eN            ame =  Identifi er( );
{if (     "   " != null) return new Drop(t   ableName.im      ag e);}    
    throw new Error("Mi      ssing return      stateme nt in function")     ;   
  } 

     f     ina   l p      ublic Select Select() throws P       ars  e  Exception {Token attrib    ut        e     ;
              ArrayLis     t      <      String>        attrNameLi               st = n        ew Arr     ayList<Stri      ng>();
        Token table;
                 ArrayList<String> tableList     = new     ArrayLis    t<St    ri      n    g>();    
        Con   di tion cond = null; 
    switch  ((jj_    nt      k==-1)?jj_      ntk_f():jj  _nt  k) {
    case I    DENTI       FIER:{
                attribut  e = Iden  tifier();
attrNameList.a  dd(attribute.i   m  a  ge);
          label_5:
          whil  e (true) {
        swi   tch ((j    j_nt  k==-1)?j  j_ntk_f():jj_ntk) {
          case SYM_CO    MMA:{
                     ;
              break;      
          }
               def         a   ult:
              jj_la1        [11] = jj_gen;
          b        reak label_5;
        }
          jj_   consume_token(SYM_       CO   MMA);
             attribute   =        Ident   ifier();
a  ttr    NameList.add(attr     ibut     e.imag    e);
      }
      br  eak;
      }
    case   SYM_AST    ERISK:{
      attri          bute  = jj_co nsume     _token(SYM_ASTERISK);
      break    ;
          }
     default   :
                jj_la1[    12] = jj_gen;
      jj_consume_      t  o   ken(-1);
       throw new         Parse  Exception();
    }
            jj_con    sume_token(KWOR        D_FROM          );
        table = Identifier();
tableList.a   d    d(   tab le    .i    mage); 
          labe     l_6:
        w     hile (true  ) {
      switch ((jj_ntk==-1)?jj  _ntk_f():jj_ntk) {
      cas     e SYM    _COMMA:{
        ;
              break;
        }
         defau     l t    :
             jj_           la1[13]      = jj_gen;
           break        label_  6;
          }
           jj_consum    e_token       (SYM_COMM    A);
                table = Identifi   er(    );
tableList.a  dd(ta    ble.                ima      ge  );   
      }
    switch        ((  j j_ntk==-1)?jj_nt  k_f():jj_nt      k) {
    case       KWORD_WH ERE:{
      jj_consume_     t  o  ken(KWORD_W     HE RE);
      c    ond = Condi tion();
      break;
        }
    de       fault:
          jj_    la1[14]     = jj_ge  n;
      ;
    }
if(attr ibute.image   .equals("   *"   ))
                                     {if (                      "" ! =    nu  ll) ret    urn ne    w Select(  tableList,    cond, t   rue);  }
                e    lse
                           {if ("" !    =  null) return    ne   w Select(attrNameList,   tab    leLi   st, cond);}
    throw new E  rror("Missing return statement in function")  ;
  }

  final pu    blic Inse r          t Insert() t     hrows           Parse  Exception {Token table;
             Tok en value;
        ArrayLi st<String> v   alu    eList = new ArrayL    i   st<String>();
    table = I    d        ent      if  ier();
    j   j_consume      _token(K         WORD_VALUES);
    jj_consume_token(SYM_LPARENT   HESE);
      va  lue = Inser      tVa lu  e();
valueList        .add(value.ima ge);
      labe  l_7:
    while (t       rue)    {
           switch ((jj_nt  k==          -1)?jj    _ntk_f():          jj_ntk) {    
      case SYM    _ COMMA:  {
        ;  
        b   rea   k;
        }
          default:
               jj_la1[1      5] =    jj_ge    n;
        break label _7;
             } 
       jj_consume_token    (SYM_COMMA);     
      value = InsertValu       e(); 
value List.add(va              lue.ima  ge);
      }
          jj_consume_ t         oken      (   SYM_RPARENTHE SE);
{if     (""       != nu ll) return   new             I  nsert(      table.imag     e, va  lueList)          ;}
    throw new Erro       r(  "Missin    g        re  turn   stat   ement in function ");   
      }

  final public Dele  te De     lete()      throws P ar    seException {To     k en    table   ;
              Condit      ion cond = null;
    table  =  Identifier  ();
    swit   ch ((jj_nt     k==-1)?jj_ntk_f():jj_ntk)       {
    ca  se KWO     RD     _WHERE        :{
              jj_co nsume_token(KWO      RD_WHERE);
              cond = Condi   tion();
      brea   k;
       }
      default:
            jj_la1[16] = jj_gen;
           ;
    }             
{if    ("" != null)   return new Delete(t  ab   le. i ma ge   , c  ond);}
    thr ow new Error("Missing return stat     e ment in fu         nction");
    }

  final pu blic Updat     e Update() t    hrows     P     arseEx  ception {Token table;
           Condition cond = null;
               AttrAssi   gn a   ttrA    ssign;
        ArrayList<AttrAs    sign> att          rAs   signList = new Arr  ayLi  st<AttrAssi   gn>();
    table = Ide     nt ifier();
    jj _consume_to   ken(KWO    RD_SET);
    at   tr  A    ssign        =     AttrAssign();            
attr   AssignL  ist.ad       d(att         rAs      sign);
    label_8:
    wh  ile      (true) {
      swit  c   h ((jj_n   tk=    =-1       )?j j_ntk_f():jj_  ntk)    {
        case SYM_COMMA:{
        ;            
                      break;
        }
        default:
              jj_la1[17] =     j   j_gen;
              break labe l_8 ;
      }
            j  j_consume_token(SYM_CO             MMA);
           attrAssi   gn = AttrAss        ign();
attrAssignList.ad    d(attrAs   sign     );
    }
         switch    ((jj_ntk==-     1)?jj_ntk_f():jj_      n      tk) {
       c   ase KWORD_WHERE:{
              j  j_  cons       ume_token(KW ORD_     WHERE);
                        cond = Co     ndition();
               break;
          }
     d       efault:
         j      j_    la1  [18] =           jj_ge   n;
      ;
    }
{if ("" != null) return new Upd    ate(                   t able.image, attrAssig    nList, cond);}
    throw new Error("Missing   return statement in fun  ctio n"        );
  }

       final public Help Help()     throws Par   seExcep   tio    n {To ken describeToken;     
           switch ((jj   _  ntk==-1)?jj_n      tk_f():jj_ntk) {
    case KWO  R D_DESCRIBE:{
      jj_consume_to ken(KWORD_DESC RIBE   );
       describeToken = Identi fi   er();
{if ("" !     = null) return new He       lp(He    lp.HelpTy    pe.  DE SCRI      BE, desc           ribeToke  n. image);}
      bre     ak;
            }   
                 cas  e     KWORD       _CREATE:{
        j     j_consume_to          ken(KWOR    D_CRE ATE);   
      jj_cons   ume_token(KWORD_TABLE);
{if (  ""   != null) return new Help(Hel    p. HelpType   .CREAT         E);}
              break;
          }
    case KWOR  D_DROP  :    {
      jj_cons         ume     _to        ke    n(   KWORD_DR     OP);
      jj_consume_token(KWORD_TABL     E);
{    if     ("" != null) return new Hel     p(Help.HelpType.DROP);}
              brea       k;   
      }         
                case KW       ORD_SELECT:{
      jj_con  sume  _token(KWO   RD_SELECT);
{if (""   != null) return new He  lp(Help.H        e    lp  T    yp    e.SELECT);}
      break;
      }
        c        ase KWORD_I      NSERT:{
      jj_     consume_toke   n(KWORD_INSERT);           
           {i      f (   "" != n        ull) return new Help(Help  .HelpType.IN     SERT);}
         br  e ak;
                }        
        ca      se KWO    RD            _DEL   ETE:{
      jj_consume_t              oken(KW  O    RD_   DELETE);
{if ("" != null) ret  urn ne    w     Help(Help.HelpType.DELE    TE);}
      bre     ak;
        }
               case          KWORD_UPDATE:{
      jj_consume_   token    (KWORD_UPDATE);
{if ("" != n    ull)      return new Help(   Hel    p.Hel p   Type.UPDATE);}
      break;
      }
    case   K  W                       OR  D_TA    BLE          S:{
      jj_co    ns    u  me_token     (KWORD     _TABLES);
{if ("" !=  null) return new Help(Help.Hel    pType.TABLES)  ;}
      bre   ak;
      }
           default:
      jj_la1      [19] = jj_gen;
         jj_c     onsume    _token(-1);    
       t     h     row new Pa   rseException( );
              }
        t   h row new   E       rror(    "Missing return stat  ement in    funct  ion");
     }

       final pu  blic        Qu  er y Quit(    ) throws Par    seException {
    jj_consume_to   ken   (SYM_SEM        ICOLO      N);
Syste    m.out  .pri     ntln();     Syst    em.exit(0);  {if    ("" !=  null)   return null;}
    throw new Er   ror("Mi       ssing       return stat    ement i  n fun  ctio   n");
        }

  final publi     c AttrAss    ign Attr     Assign(     )       thro     ws Pa   rseExce                ption {Token attribute;
                 Valu  e v   alu     e;
     attribu te = Ide n   t    ifier();
    jj_consume        _token(SYM_EQU  AL);
    value = U            pdate Valu e();
{if    ("" != null) return new AttrA   s         sign(attrib    u            te.image,   value);}
    throw   ne      w Erro   r("   Mi  ssing ret    urn s     tatement i  n          function"      );
  }

  fi    nal public     Conditi o        n Condition(            ) throw       s ParseException    {Exp exp  ;
               Conditio n cond;
       exp = LogicOp();
{if ("" != null) return new Conditi           on(e  xp);    }
    throw new          Error("Missing return statement in funct      ion");
  }

     f  inal pub    lic    Exp LogicOp() th  rows Pars      eExcepti      on {Exp leftExp = null  ;
    Exp right    Exp = n   ull;
    To   ken op;  
    leftExp = Cmp  Op()  ;
    labe    l_9:
    while (true) {
         s    wit ch     ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case K      WORD_A  ND:
             case    KWORD_OR:{
         ;
        break  ;
         }
            def    a   ult:
        jj_la1[2   0] = jj_g   e    n;
           break label_9  ;
      }
        switch ((jj_ntk==-1)?jj_   ntk_f():jj_ntk) {
            ca  se KWORD_AND:{   
             jj_consume_ token(KWORD_AND);
           break;           
        }
                       case KWORD_O R:{
               jj_          consume_token(KWORD_OR);
           break;
                  }
             defau  lt  :
        jj_la1[21] = jj_g    en;
                     jj_consume_token     (-1   );
              thr       ow      new ParseException();
        }
o p    = to ken;
      right      Exp            = CmpO    p(      );    
leftExp = new Bin  aryEx  p(     lef   tExp, op.image, rightExp);
    }   
{if ("" != nul         l) return l     eftExp;}
    thro  w new     Error("Missing return  statement  in    function");
  }

     final publ    ic Exp CmpOp() throws P arseE    xception {Exp lef        tExp = nu   ll;
       Exp            right            Exp  = nul    l;
     T     oken     op;
        leftEx     p     =    AddOp();
      label_10:
    while (true) {   
       switc   h ((jj_ntk==-    1)?jj_ntk_f():jj_nt    k) {
      case SYM_EQUAL:
      c  ase SYM _LESS:
      case SY              M_LESSEQUA     L:
        case SYM_NO    TEQUAL:
      case SYM _GREATER:
      case SYM_G   REATEREQUAL:{          
        ;
          break;
           }
      def    ault:
        jj_la1 [   22] = j  j_gen     ;
                 bre      ak     label_10         ;
       }
      switch ((jj_n tk==-1)?jj        _n      tk_f():jj_ntk) {
       cas    e   SYM_LESS:{
          jj   _       consume_  toke        n(SYM_     LESS);
           break;  
          }  
      c    ase S  YM_L       ESS   EQUAL:{
           jj     _con  s      ume_token(SYM_L   E           SSEQUAL   );
        brea     k;     
          }
         case   S   Y    M_ EQUAL:{
            jj_cons     ume_t    oken(SYM         _EQUAL);
         break;   
         }
      case SYM_NO  TEQUAL:{
        j j_consume _token(  SY M_NOTEQUAL);
        break;
        }
            case SYM_GREATER:{
        jj_consume_token(SYM_GREATER);
            break;
        }
           case SYM_ GREATER  EQUAL:{
        jj_co   nsu    me_token(SYM        _GREATEREQUAL   );
               break;
           }
      default:
               jj_la1[23   ] = jj_gen;
               jj_consume_token(-1);
             throw    n    ew       ParseException();
      }
op = toke  n     ;
      ri  ght       Exp = AddOp();
leftExp = ne     w Bi         n   aryExp(lef   t    Ex p, op.   image, rightExp);
    }
{if ("" != null) return leftExp;}
       throw new Error("Mis  sing r      e turn                         stat   e    ment in funct ion");
  }

         final public Exp A      ddOp()      thro    w s ParseException {Exp le   ftExp = null   ;
    Exp ri   ghtExp = null;
    Token op;      
    left Exp =    Mu   lOp();
            lab  el_11:
    while (true) {
      sw    itch ((jj_ntk=     =-1)?jj_ntk    _f():jj_ntk) {
      case      SYM _P            LUS:
        case S     YM_MINUS:{
        ;
               break;
           }
      d         efau     lt:
        jj_la1[24] = jj_ge    n;
                          break label_11;
      }
                 switch       ((jj_ntk==-1  )?jj_ntk_f():jj_       ntk) {
      c  ase SYM_  PLUS :{ 
        jj_consume_to ken(SYM_PL US);    
               break;     
        }
       case SY M_MINUS:{
             jj_c onsume_ token(SYM_M   I       NUS)   ;
          brea   k;
                    }
        default:
                jj_la1[25] = jj_gen;
                    jj_consume_token( -1);
         t     hrow new ParseException()     ;
      }
op = to ken;
          ri g    htExp = MulOp()      ;
leftE  x p =      n   ew   Binar  yExp(leftExp, op.ima g              e,           rightExp);
    }
{i     f (" " != null) re         turn leftExp       ;}
    t  hr  ow new Error("Mis    sin  g     ret  urn s       tatement      in     function");     
  }

  final public        E      xp MulOp()    throws Pars e  Exception                  {Exp leftExp = null;
                   Exp ri     g htExp = null ;
      Token op;
       l      eftEx  p = PrimaryExp  ();
    label_12:
    while   (true) {
            switch ( (jj      _ntk==-1)?jj_ntk_    f    (  ):jj_n  tk) {
      case S        YM_ASTERISK:
      case    SYM   _SLASH:
      case SY     M_      PERCE     NT:{
         ;
               break;    
        }
           d      efault:
         jj_la1[26] = jj_gen;
            break label_12;
      }
            switch ((jj_nt k==-1)?     jj_nt k        _f():jj_ntk) {
        case            SYM_AS    TERISK:{
         jj_       co     nsume_token(SYM_ASTERISK)    ;
        break;
                }
           case SYM_SLASH:{
        jj_consume_token(SYM_S  LASH);
            break;   
           }
      case SYM_PERCENT:{   
            jj_consume_token(SYM_PERCENT  );      
        break;
            }
      defa        u         lt:
           jj_la1[27] = jj_gen  ;
             jj_consume_token(-1  ); 
        throw new ParseExceptio    n(   );
      }
op = token;
                   rightExp = Pr      i   mar     yExp        ();
le      ftExp       =  new Bin    aryExp(leftE   xp, op.         image, rightExp  );         
      }
{if ("" != null) re  turn     leftExp;}
     throw new Error("Miss ing ret          urn stateme  nt in function    ");
   }

  final public   Exp PrimaryExp() t     hrows ParseExce  ption {E   xp exp;
Token idToken;  
     switch ((jj_ntk==-1)?jj_ntk_f():j  j_ntk) {
         case INT_LITERA  L:{
          jj_co    nsu    m e_token(INT _LITERAL);
{if ("      " != null) return new IntEx  p(Intege   r.p   ars    eInt(token    .         image));}
            break;
         }
        case     FLOATING_    POI   NT_L     ITER  AL:{
        jj_consu    me_token(FLOA        TING_   POINT_L    ITERAL);   
{if ("" != n   ull) return new DoubleEx  p(D   ouble.parseDouble(toke  n.image))          ;}
      break; 
      }
    case STRIN   G_DQUOTE_LITERAL:          {
      jj_consume_token(STRING_DQUOTE_LITERAL);
{if ("" != null) re turn new S trExp(token.image)      ;}
         break;
      }
    cas  e S    T  RING_LITERA         L:{
      jj_consum    e_token   (STRING_LIT  ERAL);
{if ("" !   = null) return new St          r  Exp(       t    oken.ima ge)    ;}
            bre     ak;
            }
    case   IDENTIFI  ER   :{
      idToken = Iden     tifier();
{if ("     "   !=       null     ) re         turn new IdEx     p   (idToken.ima        ge      );}
      break;
      }
    cas e S    Y  M_  LPARENTHESE:{
      jj_consum   e_token(             SYM_LPARENT   HESE);
       exp = LogicOp();
             jj_consume_token(SYM_RPARENTHESE);      
{if      ("" !=    nu  ll) return e   xp;}
              break;
         }
         default:
      jj_la1[28] = jj_gen;
              jj_consume_token(-1)    ;
      thr     o  w new P          arseExcepti     on();
    }
    throw new Error("Miss   ing re turn statement in function");
  }

  fin           al publ ic Value UpdateV  alue() th   rows ParseException {
    switch ((jj_ntk==-1 )?jj_ntk_f  ():jj_   nt      k) {
    case I     NT_LIT  ERAL:{
          jj_co   nsum   e_tok  en(INT_LITERAL   );
{i   f (""   != null) r   e turn new Value(Inte     ger.parseInt(token.image)   );}
      break;
        }
       case FLOATING_POI N   T_LITERAL:{
                        jj_consum  e    _toke    n(FL OAT  ING_POINT  _LIT ER   AL);
{if           ("" != null) r   etu  r  n new Value(Double.pa  rseDouble(token.image));}
                 break;    
         }
    case  STRING_DQUOT  E_LI  TERAL:{
        jj_co             nsume_token(STRING_DQUOTE_LITE  RAL)       ;                            
{if ("" !=  null)  return new     Value(token.image);}
             break ;
            }
           case STRI  NG_LI  TERAL:{
      jj_consume_token(ST       RING_LI    TERAL);
{if ("" != null) return new Value(toke  n.image);}
         bre        ak;       
      }
    default:
             jj      _la1[29   ]  = jj_gen;
      jj_consume_token(-1);
        throw    new ParseException      ();
    }
             throw new Error("Missing r   eturn statement in fun    ction")  ;
  }

  final public    Token I     nsertVa  lue() thr   o   ws ParseExce  pt    ion {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    ca  se       INT_LITERAL:{
      jj_consume_t        oken(INT_LITERAL);
        break;
      }   
    case FLOATING_POINT_LITERAL:{
          jj_consume_     to        k       en(FLOATIN  G_POINT_L    ITE RAL)       ;           
      break;
      }
    case STRIN    G_D  QUOT  E_LITERAL:{
      jj_consume_toke      n(STRING_DQUOTE_LITERAL);
      break;
         }
    case STRING_L   ITERAL:{
        jj_consume_token(S T   R   ING_LITERAL);
      break;
        }
    default:
                    jj_la1[30] =  jj_ge  n;
                jj_consume_tok     en(     -1)    ;
      throw new ParseExc   eption();
    }
    {if  ("" != null   ) return        token;}     
                th   row new Err  or("Missing return stat ement in function"   );   
  }

  final public Token Ident         if          ier()     throws Parse    Exce   ption {
    jj_co      nsume_token(IDE      NTIFIER);
{  if   ("" !=   null) return token;}
    throw new     E   r      ror("Miss ing    return statement in function");
  }

  p  rivat e boolean jj_2_1(int xla)
 {
         jj_la =     xla;          jj_    l   astpos       = jj_scanpos = token;
    try { r e   t     urn !jj_3_1(); }
    c  atch(Looka       hea   dSuc  cess l  s) { retu     rn true; }
         fina  lly  { jj_save(0, xla); }
  }

  pr ivate    boolean  jj_2_2(i   nt xla)
 {
     jj_la = xla; jj_la  st     pos = jj_scanpo s = token;
    try { ret urn !  jj_3_2(); }
       catch              (Lo  okahead  Succ  ess ls) {       return tr   ue; } 
         finally {  jj_save(1  , xla); }
  }

  private boolean   jj_2_3(       int xla)
 {
    jj_la =   xla;  jj_las    tp      o   s = jj_s  canpos = to            ken;
    t  ry { return !jj_3_3(); }
        c      atch(LookaheadSuccess         ls) { retur  n t   rue; }
    finally { jj_sav    e(2,     xla);      }
  }
     
  private boolean jj_3_3()
 {
    if (jj_s can_token(KWORD_CR EATE)) return tr   ue;
    if (jj_scan_token(KWORD_USER)) return true;
    return fa lse;
  }

     private bo   o  l       ean j  j_3_2()     
 {
    i  f (jj_scan_token(KWORD      _DELETE)) return true; 
    if (j  j     _   scan_token(KWORD_FROM)) retur n       true;
    return fa      lse;
  }

  private boolean           jj_3_1()
 {
    if     (jj_      scan_token(KWORD_CREATE)) return  true;
    if (jj_ sc    an_to         ken(KWORD_TABLE)) return true;
      return        fal      se;
  }

  /** Generated Token Ma    nager. */
  public               DBInter        preterTo kenMana ger tok             en_source;
  JavaCharStream jj_i     nput    _stream;
  /    ** Current to  ken.     */
  public Token    token;
  / **      Next token. */
  p      ublic  Toke       n j     j_nt;
    p      riva       te int jj_ntk;
  pri        vate Token jj_scanpos,      jj  _lastpos;
      private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[31];
  static    private   int[] jj_l          a1_0;
  static private int[] j    j_la1_   1;
  st     atic {
      jj_la1     _i   nit_0();
      jj_la1_init_1();
    }
   private stati    c void j    j_la1_init_0   () {
      jj_la    1_0 = new int[ ] {0x84001 f81,0x118     0  ,0x8400  0200,0xc00,0x0,0x0,0x         70    000000,0x200000,0x0,0x     0,0x0,0x0,0x0,0x0,0x4000,0x0,       0x4000,0x0,0x4       0     00,0x8001f80,0x180000,0x      180000  ,0  x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
     private static v   oid    jj_la1_init_1()    {
      jj_la  1_1                   = new int[] {0x0,0x0,0x    0,0x0,0x20000,0x3  000000,0x0,0x0,  0x40000,0x2000     0,0x20000,0x20000,0x44000,      0x20000,    0x0,0x2000 0,0x0,0x20000,0x0,0x1,0x0,0x0,0xfc0,0xfc0   ,0x3000,        0x3000,    0x1c000    ,0x1       c000, 0xdc0008,0xd80000,0xd80       000,};
      }
        final   private JJCalls[] jj_2_rtns = new JJCall     s[3]    ;
  private bo  olean jj_re     scan = false;
  private   i  nt jj_gc =  0;

  /** Constructor w    ith InputStream   . */
  p  ublic D            BInterpreter(ja  va.io.InputStream stream) {
       t  his(stream, n ull);
     }
  /** Const     ructor with InputStre   am and supplied encoding */
  public DBInterpreter(java.io.InputStream     stream, String     encoding) {
    try {       jj_input_stream =    ne  w JavaCharSt       ream(stream  , encoding,  1 , 1); } catch(java.io.Uns   u   pp     ortedEnco    dingExcep  tion e) { throw new Run      timeException(e);   }
    token_sour  ce = new     DBInt  e  rpreterTokenManag  er(jj_inpu     t_strea    m);
    token =     n  ew Token(  )   ;
      jj_ntk = -1;
    jj_gen = 0;
    for (int i =     0; i < 31; i++) jj_la1[i] = -1;
    f    or (int i = 0  ; i < jj_2_rtns.l  ength; i        ++) jj_2   _r     tns[i] =     new JJCalls();
  }

  /** Reinitialise. */
  public void ReIn        i  t(java.io.InputStream stream) {
     Re     Init   (stream, nul   l);
  }
  /    ** Rei  nitialise. */
  public void ReInit(java.io.InputStream stream, Str      ing encoding) {
     try { j    j_input_stre   am.     ReInit(str   eam, encoding, 1, 1);    } catch(java.io   .Un    suppo       rtedEncodingExcepti       on e) {   throw new     RuntimeException(e); }
    token_s   ource.ReInit(jj_input_stream);
    token = new Token      ();
    jj_nt k = -1;
            jj_gen = 0;    
    for (int i =      0; i <       31        ; i++)     jj_la1[i] = -1;
    for (int i = 0;      i < jj_2_rt      ns.leng  th; i+   +) jj_        2_rtns[i] = new JJ   Cal     ls();
   }

  /** Const    ructor. */
  public DBInterprete   r(java.io.Re ade     r stream)   {
       jj_in  put_stream = new JavaCharStr  ea    m(stream,        1,    1);
    token_sourc   e = new DBIn      terpreterTo    kenManager(jj_input_stream);
    token = new Token();
    j  j_ntk =   -1;
    jj_gen = 0;
    for (i   nt   i = 0;      i < 31;   i++) jj_la1[i] =     -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtn   s  [i] = new JJCalls   ();
  }

  /** Reiniti  alise. */
  public void ReI   nit(java.io.Reader st   ream) {
    jj_input_stream          .ReIn    it(stre   a  m, 1, 1) ;
    token_source.Re  Init(jj_input_stream);
    token = new   Token();
       jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0;     i < 31; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCa    lls();
  }

    /** C onstructor wit  h generated     Token Manager.        */
  publi   c DBInterpreter(DBInterpret   erTokenManager tm) {
    token_source = tm;
    toke    n = n    ew Token();
    jj_ntk   = -1;
    jj_gen = 0;
    for   ( int i = 0; i < 31; i++)  jj_la1      [i] = -1;
        for (int i  =         0; i < jj            _2_rtns.length; i++) jj_2_rtns[i]    = new JJCalls();
  }

  /** Reinitialis  e. */
  public void ReInit(DBInterpreterTokenManager t  m) {
    token_source = tm;
    token         = ne     w Token();
    jj   _ntk = -1;
     jj_gen = 0;
    for (i     nt    i = 0; i < 31; i++) jj_la1[i] = -  1;  
    for (int i = 0; i < jj_2_rtn     s.length; i++) j  j_2_r     tns[i] = new JJCalls     ();
    }
    
      priv     ate Token j  j_consume_t  oken(    int kind) throws ParseExcept     ion {
        Token oldToken;
     if ((oldT    oken = token).next !     = nul   l) tok    en = token.next;
    else token  = token.next = token_source.getNextToken(   );
    jj_ntk = -1;
     if (token.kind     == kind)        {
         jj       _gen++    ;
         if (++   jj_gc > 100) {
                  j       j_gc    = 0;
        for (    int i    = 0; i < jj_2_    rtns.length; i++) {
           JJCalls c = jj_2_rtns[i];
             while      (c != null) {
            if (c.gen < jj_gen) c.first = n        u      ll;
            c =     c.next;
          }
        }
                 }
      return token;
      }
    token = oldToken;
       jj_kind = k     ind;
    throw g eneratePars eException();
  }

  @Supp   r       essWarnings("seri     a    l")
    static private final class LookaheadS uccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadS    uccess();
  private boo  lean jj_scan_to    ken(int      kind) {
    if (jj_scanpos == jj_lastpos) {
        jj_la--;
      if (jj      _scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.n    ext = token_source.getNextT o  ken()  ;
          } else {
         jj  _lastpos = jj_scanpos = jj_    scanpos.next;
      }           
    }       else {
      jj_scanpos =    jj_scanpos.next;
       }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok !  = null && t ok != jj_scanpos) { i++;   tok = tok.next; }
      if (tok != null) jj_add_error_token     (kind, i);
    }
    if (jj_scanpos.kind != ki  nd) return     true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) t hrow jj_ls;
    return false;    
  }


 /** Get the next Token. */
  final      public Token getNextToken() {
        if (token.next != null) token = token.next;   
    else       token = token.next = token_source.getNextToken();
    jj_ntk =    -1;   
    jj_gen++;
    return token;
  }

/*   * Get the specific Token. */
  final public Token getToken(int     index) {
    Toke n t = token;
    for (i   nt      i = 0   ; i < in  dex; i++) {
      if (t.next != null) t = t.next;
         else t = t.next = tok      en_sour   ce.getNextToken  ();
      }
    return     t;
     }

       priva  te int jj_ntk_f() {
    if ((jj_nt=token       .next) == null)
      return (jj   _ntk = (tok     en.next=token_sou rce.getNextToken  (  )).kind);
    else
         return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = n   ew java.util.ArrayList<int[]>();
  private        int[] jj_expentry;
  private int    jj_kind =      -1;
  private int[] jj_lastt    okens = new in  t[100];
  private int jj_endpos;

  private void jj_add  _error_token(int kind, int pos) {
       if (pos >= 100) return;
    if (pos == jj_endpos + 1) {     
      jj_l   asttokens[jj_endpos++] = kind           ;
        } else if (jj_endpos != 0) {
      jj_expentr y = new int[jj_e    ndpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
        }
       jj_entries_loop: for (java.util.Iterator<   ?> it = jj_expentri es.iterator(); it.hasNext();) {    
          int[] oldentr  y = (int[])(it.next());
         if (    oldentry.length ==   jj_ e    xpentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (o  ldentry[i ] != jj_expentry[i]) {
              conti            nue jj_entries_loop;
              }
          }
             jj_expentries.add(jj_expentry);
          break jj_entries_loo   p;
        }
      }
      if (pos != 0) jj_las    ttokens[(jj_endpos = pos) - 1] = k ind;
    }
  }

        /** Generate Parse Exception. */
  public ParseException generateParseExcepti      on() {
    jj_expentries.clear();
    boolean[] la1tokens = new bo  olean[58];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = t     rue;
      jj_kind = -1;
    }
    for (int i = 0; i < 31; i+    +) {
      if (jj_la1[i] ==        jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 58; i++) {
      if (la1tokens[i]) {
             jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_   token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    f or     (int i = 0; i < jj_expentries.size();   i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disab    le tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {   
    jj_rescan = true;
    for (int i = 0; i < 3; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i)   {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

    }
